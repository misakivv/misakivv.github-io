{"meta":{"title":"my blog","subtitle":"","description":"blog","author":"John Doe","url":"https://misakivv.github.io","root":"/"},"pages":[{"title":"friends","date":"2023-11-12T02:02:15.000Z","updated":"2023-11-12T02:34:51.124Z","comments":true,"path":"friends/index.html","permalink":"https://misakivv.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"嵌入式Day10","date":"2023-11-12T06:41:03.506Z","updated":"2023-11-08T15:31:05.614Z","comments":true,"path":"2023/11/12/嵌入式Day10/","permalink":"https://misakivv.github.io/2023/11/12/%E5%B5%8C%E5%85%A5%E5%BC%8FDay10/","excerpt":"","text":"QT多线程02继承QObject的线程 继承QObject类更加灵活。它通过 QObject::moveToThread()方法将它移到一个 QThread 线程里 执行。那么可以通过主线程发送信号去调用 QThread 线程的方法如上图的 fun4()，fun5()等等。这些方 法都是在 QThread 线程里执行的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;#include &lt;QMutexLocker&gt;#include &lt;QMutex&gt;/* 工人类 */class Worker;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 开始线程按钮 */QPushButton *pushButton1;QPushButton *pushButton2;/* 全局线程 */QThread workerThread;/* 工人类 */Worker *worker;private slots:/* 按钮 1 点击开启线程 */void pushButton1Clicked();/* 按钮 2 点击打断线程 */void pushButton2Clicked();/* 用于接收工人是否在工作的信号 */void handleResults(const QString &amp;);signals:/* 工人开始工作（做些耗时的操作 ） */void startWork(const QString &amp;);&#125;;/* Worker 类，这个类声明了 doWork1 函数，将整个 Worker 类移至线程 workerThread*/class Worker : public QObject&#123;Q_OBJECTprivate:/* 互斥锁 */QMutex lock;/* 标志位 */bool isCanRun;public slots:/* 耗时的工作都放在槽函数下，工人可以有多份不同的工作，但是每次只能去做一份 */void doWork1(const QString &amp;parameter) &#123;/* 标志位为真 */isCanRun = true;/* 死循环 */while (1) &#123;/* 此&#123;&#125;作用是 QMutexLocker 与 lock 的作用范围，获取锁后，* 运行完成后即解锁 */&#123;QMutexLocker locker(&amp;lock);/* 如果标志位不为真 */if (!isCanRun) &#123;/* 跳出循环 */break;&#125;&#125;/* 使用 QThread 里的延时函数，当作一个普通延时 */QThread::sleep(2);emit resultReady(parameter + &quot;doWork1 函数&quot;);&#125;/* doWork1 运行完成，发送信号 */emit resultReady(&quot;打断 doWork1 函数&quot;);&#125;// void doWork2();...public:/* 打断线程（注意此方法不能放在槽函数下） */void stopWork() &#123;qDebug()&lt;&lt;&quot;打断线程&quot;&lt;&lt;endl;/* 获取锁后，运行完成后即解锁 */QMutexLocker locker(&amp;lock);isCanRun = false;&#125;signals:/* 工人工作函数状态的信号 */void resultReady(const QString &amp;result);&#125;;#endif // MAINWINDOW_H 第 51105 行，声明一个 Worker 的类继承 QObject 类，这里是参考 Qt 的 QThread 类的帮助文档的 写法。 第 6288 行，我们把耗时的工作都放于槽函数下。工人可以有不同的工作，但是每次只能去做一份。 这里不同于继承 QThread 类的线程 run()，继承 QThread 的类只有 run()在新线程里。而继承 QObject 的类，使用 moveToThread()可以把整个继承的 QObject 类移至线程里执行，所以可以有 doWork1(),doWork2…等等耗时的操作，但是这些耗时的操作都应该作为槽函数，由主线程去调用。 第 67~80 行，进入循环后使用互拆锁判断 isCanRun 变量的状态，为假即跳出 while 循环，直到 doWork1 结束。注意，虽然 doWork1 结束了，但是线程并没有退出（结束）。因为我们把这个类移到 线程里了，直到这个类被销毁。或者使用 quit()和 exit()退出线程才真正的结束！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475mainwindow.cpp#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置显示位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);pushButton1 = new QPushButton(this);pushButton2 = new QPushButton(this);/* 设置按钮的位置大小 */pushButton1-&gt;setGeometry(300, 200, 80, 40);pushButton2-&gt;setGeometry(400, 200, 80, 40);/* 设置两个按钮的文本 */pushButton1-&gt;setText(&quot;开启线程&quot;);pushButton2-&gt;setText(&quot;打断线程&quot;);worker = new Worker;/* 将 worker 类移至线程 workerThread */worker-&gt;moveToThread(&amp;workerThread);/* 信号槽连接 *//* 线程完成销毁对象 */connect(&amp;workerThread, SIGNAL(finished()),worker, SLOT(deleteLater()));connect(&amp;workerThread, SIGNAL(finished()),&amp;workerThread, SLOT(deleteLater()));/* 发送开始工作的信号，开始工作 */connect(this, SIGNAL(startWork(QString)),worker, SLOT(doWork1(QString)));/* 接收到 worker 发送过来的信号 */connect(worker, SIGNAL(resultReady(QString)),this, SLOT(handleResults(QString)));/* 点击按钮开始线程 */connect(pushButton1, SIGNAL(clicked()),this, SLOT(pushButton1Clicked()));/* 点击按钮打断线程 */connect(pushButton2, SIGNAL(clicked()),this, SLOT(pushButton2Clicked()));&#125;MainWindow::~MainWindow()&#123;/* 打断线程再退出 */worker-&gt;stopWork();workerThread.quit();/* 阻塞线程 2000ms，判断线程是否结束 */if (workerThread.wait(2000)) &#123;qDebug()&lt;&lt;&quot;线程结束&quot;&lt;&lt;endl;&#125;&#125;void MainWindow::pushButton1Clicked()&#123;/* 字符串常量 */const QString str = &quot;正在运行&quot;;/* 判断线程是否在运行 */if(!workerThread.isRunning()) &#123;/* 开启线程 */workerThread.start();&#125;/* 发送正在运行的信号，线程收到信号后执行后返回线程耗时函数 + 此字符串 */emit this-&gt;startWork(str);&#125;void MainWindow::pushButton2Clicked()&#123;/* 如果线程在运行 */if(workerThread.isRunning()) &#123;/* 停止耗时工作，跳出耗时工作的循环 */worker-&gt;stopWork();&#125;&#125;void MainWindow::handleResults(const QString &amp; results)&#123;/* 打印线程的状态 */qDebug()&lt;&lt;&quot;线程的状态：&quot;&lt;&lt;results&lt;&lt;endl;&#125; 第 20 行，工人类实例化。继承 QObject 的多线程类不能指定父对象。 第 24 行，工人类实例化后，工人类将自己移至 workerThread 线程里执行。 第 29~32 行，线程结束后，我们需要使用 deleteLater 来销毁 worker 对象和 workerThread对象分配 的内存。deleteLater 会确认消息循环中没有这两个线程的对象后销毁。 网络编程1234567Qt网络模块为我们提供了编写 TCP / IP 客户端和服务器的类。它提供了较低级别的类，例如代表低级网络概念的 QTcpSocket，QTcpServer 和 QUdpSocket，以及诸如 QNetworkRequest，QNetworkReply和 QNetworkAccessManager 之类的高级类来执行使用通用协议的网络操作。 它还提供了诸如QNetworkConfiguration，QNetworkConfigurationManager和QNetworkSession等类，实现承载管理。想要在程序中使用 Qt 网络模块，我们需要在 pro 项目配置文件里增加下面的一条语句。QT += network 获取本机的网络信息为什么先写获取本机网络信息的内容呢？在建立网络通信之前我们至少得获取对方的 IP地址。在网络应 用中，经常需要用到本机的主机名、IP 地址、MAC 地址等网络信息，通常通在 Windows 通过调出命 令行 cmd 窗口输入 ipconfig 或者在 Linux 系统中使用 ifconfig 命令就可以查看相关信息了，在这里我 们利用 Qt 做出一个可以查询的界面和功能出来。 Qt 提供了 QHostInfo 和 QNetworkInterface 类可以用于此类信息查询。更多关于 QHostInfo和 QNetworkInterface 的相关函数可以在 Qt 的帮助文档中找到。 123456789101112131415161718192021222324252627//networkhostinfo.proQT += core gui networkgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsCONFIG += c++11# The following define makes your compiler emit warnings if you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain#version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the#APIs deprecated before Qt 6.0.0SOURCES += \\main.cpp \\mainwindow.cppHEADERS += \\mainwindow.h# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target 12345678910111213141516171819202122232425262728293031323334353637383940414243//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QPushButton&gt;#include &lt;QTextBrowser&gt;#include &lt;QVBoxLayout&gt;#include &lt;QHBoxLayout&gt;#include &lt;QTimer&gt;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 点击获取和清空文本按钮 */QPushButton *pushButton[2];/* 文本浏览框用于显示本机的信息 */QTextBrowser *textBrowser;/* 水平 Widget 容器和垂直 Widget 容器*/QWidget *hWidget;QWidget *vWidget;/* 水平布局和垂直布局 */QHBoxLayout *hBoxLayout;QVBoxLayout *vBoxLayout;/* 定时器 */QTimer *timer;/* 获取本机的网络的信息，返回类型是 QString */QString getHostInfo();private slots:/* 定时器槽函数，点击按钮后定时触发 */void timerTimeOut();/* 显示本机信息 */void showHostInfo();/* 启动定时器 */void timerStart();/* 清空 textBrowser 的信息 */void clearHostInfo();&#125;;#endif // MAINWINDOW_H 头文件里主要是声明两个按钮和一个文本浏览框。另外还有一个定时器，声明一些槽函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &lt;QtNetwork/QNetworkInterface&gt;#include &lt;QtNetwork/QHostInfo&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);/* 点击获取本地信息按钮和清空文本按钮 */pushButton[0] = new QPushButton();pushButton[1] = new QPushButton();pushButton[0]-&gt;setText(&quot;获取本机信息&quot;);pushButton[1]-&gt;setText(&quot;清空文本信息&quot;);/* 按钮的大小根据文本自适应，* 注意 setSizePolicy 需要在布局中使用 */pushButton[0]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);pushButton[1]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);/* 水平 Widget 和垂直 Widget 用于添加布局 */hWidget = new QWidget();vWidget = new QWidget();/* 水平布局和垂直布局 */hBoxLayout = new QHBoxLayout();vBoxLayout = new QVBoxLayout();/* 文本浏览框 */textBrowser = new QTextBrowser();/* 添加到水平布局 */hBoxLayout-&gt;addWidget(pushButton[0]);hBoxLayout-&gt;addWidget(pushButton[1]);/* 将水平布局设置为 hWidget 的布局 */hWidget-&gt;setLayout(hBoxLayout);/* 将文本浏览框和 hWidget 添加到垂直布局 */vBoxLayout-&gt;addWidget(textBrowser);vBoxLayout-&gt;addWidget(hWidget);/* 将垂直布局设置为 vWidget 的布局 */vWidget-&gt;setLayout(vBoxLayout);/* 设置 vWidget 为中心部件 */setCentralWidget(vWidget);/* 定时器初始化 */timer = new QTimer();/* 信号槽连接 */connect(pushButton[0], SIGNAL(clicked()),this, SLOT(timerStart()));connect(pushButton[1], SIGNAL(clicked()),this, SLOT(clearHostInfo()));connect(timer, SIGNAL(timeout()),this, SLOT(timerTimeOut()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::timerStart()&#123;/* 清空文本 */textBrowser-&gt;clear();/* 定时 1s */timer-&gt;start(1000);&#125;void MainWindow::timerTimeOut()&#123;/* 显示本机信息 */showHostInfo();/* 停止定时器 */timer-&gt;stop();&#125;QString MainWindow::getHostInfo()&#123;/* 通过 QHostInfo 的 localHostName 函数获取主机名称 */QString str = &quot;主机名称：&quot; + QHostInfo::localHostName() + &quot;\\n&quot;;/* 获取所有的网络接口，* QNetworkInterface 类提供主机的 IP 地址和网络接口的列表 */QList&lt;QNetworkInterface&gt; list = QNetworkInterface::allInterfaces();/* 遍历 list */foreach (QNetworkInterface interface, list) &#123;str+= &quot;网卡设备:&quot; + interface.name() + &quot;\\n&quot;;str+= &quot;MAC 地址:&quot; + interface.hardwareAddress() + &quot;\\n&quot;;/* QNetworkAddressEntry 类存储 IP 地址子网掩码和广播地址 */QList&lt;QNetworkAddressEntry&gt; entryList = interface.addressEntries();/* 遍历 entryList */foreach (QNetworkAddressEntry entry, entryList) &#123;/* 过滤 IPv6 地址，只留下 IPv4 */if (entry.ip().protocol() == QAbstractSocket::IPv4Protocol) &#123;str+= &quot;IP 地址:&quot; + entry.ip().toString() + &quot;\\n&quot;;str+= &quot;子网掩码:&quot; + entry.netmask().toString() + &quot;\\n&quot;;str+= &quot;广播地址:&quot; + entry.broadcast().toString() + &quot;\\n\\n&quot;;&#125;&#125;&#125;/* 返回网络信息 */return str;&#125;void MainWindow::showHostInfo()&#123;/* 获取本机信息后显示到 textBrowser */textBrowser-&gt;insertPlainText(getHostInfo());&#125;void MainWindow::clearHostInfo()&#123;/* 判断 textBrowser 是否为空，如果不为空则清空文本 */if (!textBrowser-&gt;toPlainText().isEmpty())/* 清空文本 */textBrowser-&gt;clear();&#125; 12345第 90~123 行，是本例最重要的代码。第 93 行，通过 QHostInfo 的 localHostName 函数获取主机名称。第 97~98 行，通过 QNetworkInterface::allInterfaces()获取网络接口列表 list 类存储 IP 地址子网掩码和广播地址。如果我们用 qDebug()函数打印出 list，可以发现获取了所有的网络信息。而我们要提取网络里面的网络信息使用 QNetworkAddressEntry。第 106~107 行，使用 QNetworkAddressEntry 从 interface 接口里使用函数addressEntries()，获取所有的条目。就可以使用 QNetworkAddressEntry 的对象 entry 获取 IP地址子网掩码和广播地址。第 110~118 行，因为获取的 entries 在一个 QNetworkInterface 下可能有两个 IP，分别是 ipv4和 ipv6。这里使用 ip().protocol()来判断协议的类型，只留下 ipv4 类型的信息。筛选信息在我们写程序常常需要的。 套接字socket编程 socket概述 接字，用于描述IP地址和端口号 socket时链接运行在网络上的两个程序间的双向通信的端点。 通讯两端都有socket，数据在两个socket之间通过IO进行传输。 套接字是一种特殊的I&#x2F;O接口，在代码内体现为特殊的文件描述符，socket是一种常见的进程间通信。 套接字主要有三种类型： 12345671、流式套接字（SOCK_STREAM）流式套接字提供可靠的，面向连接的通信流，保证数据传输的可靠性和有序性。TCP通信使用该套接字。2、数据报套接字（SOCK_DGRAM）提供不可靠、无连接的通信流，不保证可靠传输、无序。UDP通信使用该套接字。3、原始套接字（SOCK_RAW）允许对底层协议进行访问，功能强大但不方便。 TCP连接的建立：三次握手 TCP连接的释放：四次挥手 socket通信 服务器端将一个套接字绑定到一个特定的端口，并通过这个套接字等待和监听客户的连接请求。 客户端根据服务器所在的主机和端口号发送连接请求。 如果一切正常，服务器接受连接请求，并且获得一个新的绑定到不同端口地址的套接字。 服务器端和客户端通过读写套接字进行通讯。 流程图 服务器端如果需要使用TCP协议创建一个服务器，需要以下步骤： 创建套接字 绑定套接字 设置监听模式 接受客户端的连接请求 接受&#x2F;发送数据 断开连接 创建套接字1234567891011121314151617socket()函数的用法：头文件#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数原型int socket(int domain, int type, int protocol);函数参数domain：选择通信协议，常见的协议：AF_INET：IPv4通信协议AF_INET6：IPv6通信协议AF_UNIX：本地通信type：套接字类型protocol：协议值，通常情况为0函数返回值成功：非负套接字文件描述符失败：-1","categories":[],"tags":[]},{"title":"QT多线程02","slug":"QT多线程02","date":"2023-11-12T06:40:02.000Z","updated":"2023-11-12T07:36:59.268Z","comments":true,"path":"2023/11/12/QT多线程02/","permalink":"https://misakivv.github.io/2023/11/12/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B02/","excerpt":"","text":"QT多线程02继承QObject的线程 继承QObject类更加灵活。它通过 QObject::moveToThread()方法将它移到一个 QThread 线程里 执行。那么可以通过主线程发送信号去调用 QThread 线程的方法如上图的 fun4()，fun5()等等。这些方 法都是在 QThread 线程里执行的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;#include &lt;QMutexLocker&gt;#include &lt;QMutex&gt;/* 工人类 */class Worker;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 开始线程按钮 */QPushButton *pushButton1;QPushButton *pushButton2;/* 全局线程 */QThread workerThread;/* 工人类 */Worker *worker;private slots:/* 按钮 1 点击开启线程 */void pushButton1Clicked();/* 按钮 2 点击打断线程 */void pushButton2Clicked();/* 用于接收工人是否在工作的信号 */void handleResults(const QString &amp;);signals:/* 工人开始工作（做些耗时的操作 ） */void startWork(const QString &amp;);&#125;;/* Worker 类，这个类声明了 doWork1 函数，将整个 Worker 类移至线程 workerThread*/class Worker : public QObject&#123;Q_OBJECTprivate:/* 互斥锁 */QMutex lock;/* 标志位 */bool isCanRun;public slots:/* 耗时的工作都放在槽函数下，工人可以有多份不同的工作，但是每次只能去做一份 */void doWork1(const QString &amp;parameter) &#123;/* 标志位为真 */isCanRun = true;/* 死循环 */while (1) &#123;/* 此&#123;&#125;作用是 QMutexLocker 与 lock 的作用范围，获取锁后，* 运行完成后即解锁 */&#123;QMutexLocker locker(&amp;lock);/* 如果标志位不为真 */if (!isCanRun) &#123;/* 跳出循环 */break;&#125;&#125;/* 使用 QThread 里的延时函数，当作一个普通延时 */QThread::sleep(2);emit resultReady(parameter + &quot;doWork1 函数&quot;);&#125;/* doWork1 运行完成，发送信号 */emit resultReady(&quot;打断 doWork1 函数&quot;);&#125;// void doWork2();...public:/* 打断线程（注意此方法不能放在槽函数下） */void stopWork() &#123;qDebug()&lt;&lt;&quot;打断线程&quot;&lt;&lt;endl;/* 获取锁后，运行完成后即解锁 */QMutexLocker locker(&amp;lock);isCanRun = false;&#125;signals:/* 工人工作函数状态的信号 */void resultReady(const QString &amp;result);&#125;;#endif // MAINWINDOW_H 第 51105 行，声明一个 Worker 的类继承 QObject 类，这里是参考 Qt 的 QThread 类的帮助文档的 写法。 第 6288 行，我们把耗时的工作都放于槽函数下。工人可以有不同的工作，但是每次只能去做一份。 这里不同于继承 QThread 类的线程 run()，继承 QThread 的类只有 run()在新线程里。而继承 QObject 的类，使用 moveToThread()可以把整个继承的 QObject 类移至线程里执行，所以可以有 doWork1(),doWork2…等等耗时的操作，但是这些耗时的操作都应该作为槽函数，由主线程去调用。 第 67~80 行，进入循环后使用互拆锁判断 isCanRun 变量的状态，为假即跳出 while 循环，直到 doWork1 结束。注意，虽然 doWork1 结束了，但是线程并没有退出（结束）。因为我们把这个类移到 线程里了，直到这个类被销毁。或者使用 quit()和 exit()退出线程才真正的结束！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475mainwindow.cpp#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置显示位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);pushButton1 = new QPushButton(this);pushButton2 = new QPushButton(this);/* 设置按钮的位置大小 */pushButton1-&gt;setGeometry(300, 200, 80, 40);pushButton2-&gt;setGeometry(400, 200, 80, 40);/* 设置两个按钮的文本 */pushButton1-&gt;setText(&quot;开启线程&quot;);pushButton2-&gt;setText(&quot;打断线程&quot;);worker = new Worker;/* 将 worker 类移至线程 workerThread */worker-&gt;moveToThread(&amp;workerThread);/* 信号槽连接 *//* 线程完成销毁对象 */connect(&amp;workerThread, SIGNAL(finished()),worker, SLOT(deleteLater()));connect(&amp;workerThread, SIGNAL(finished()),&amp;workerThread, SLOT(deleteLater()));/* 发送开始工作的信号，开始工作 */connect(this, SIGNAL(startWork(QString)),worker, SLOT(doWork1(QString)));/* 接收到 worker 发送过来的信号 */connect(worker, SIGNAL(resultReady(QString)),this, SLOT(handleResults(QString)));/* 点击按钮开始线程 */connect(pushButton1, SIGNAL(clicked()),this, SLOT(pushButton1Clicked()));/* 点击按钮打断线程 */connect(pushButton2, SIGNAL(clicked()),this, SLOT(pushButton2Clicked()));&#125;MainWindow::~MainWindow()&#123;/* 打断线程再退出 */worker-&gt;stopWork();workerThread.quit();/* 阻塞线程 2000ms，判断线程是否结束 */if (workerThread.wait(2000)) &#123;qDebug()&lt;&lt;&quot;线程结束&quot;&lt;&lt;endl;&#125;&#125;void MainWindow::pushButton1Clicked()&#123;/* 字符串常量 */const QString str = &quot;正在运行&quot;;/* 判断线程是否在运行 */if(!workerThread.isRunning()) &#123;/* 开启线程 */workerThread.start();&#125;/* 发送正在运行的信号，线程收到信号后执行后返回线程耗时函数 + 此字符串 */emit this-&gt;startWork(str);&#125;void MainWindow::pushButton2Clicked()&#123;/* 如果线程在运行 */if(workerThread.isRunning()) &#123;/* 停止耗时工作，跳出耗时工作的循环 */worker-&gt;stopWork();&#125;&#125;void MainWindow::handleResults(const QString &amp; results)&#123;/* 打印线程的状态 */qDebug()&lt;&lt;&quot;线程的状态：&quot;&lt;&lt;results&lt;&lt;endl;&#125; 第 20 行，工人类实例化。继承 QObject 的多线程类不能指定父对象。 第 24 行，工人类实例化后，工人类将自己移至 workerThread 线程里执行。 第 29~32 行，线程结束后，我们需要使用 deleteLater 来销毁 worker 对象和 workerThread对象分配 的内存。deleteLater 会确认消息循环中没有这两个线程的对象后销毁。 网络编程1234567Qt网络模块为我们提供了编写 TCP / IP 客户端和服务器的类。它提供了较低级别的类，例如代表低级网络概念的 QTcpSocket，QTcpServer 和 QUdpSocket，以及诸如 QNetworkRequest，QNetworkReply和 QNetworkAccessManager 之类的高级类来执行使用通用协议的网络操作。 它还提供了诸如QNetworkConfiguration，QNetworkConfigurationManager和QNetworkSession等类，实现承载管理。想要在程序中使用 Qt 网络模块，我们需要在 pro 项目配置文件里增加下面的一条语句。QT += network 获取本机的网络信息为什么先写获取本机网络信息的内容呢？在建立网络通信之前我们至少得获取对方的 IP地址。在网络应 用中，经常需要用到本机的主机名、IP 地址、MAC 地址等网络信息，通常通在 Windows 通过调出命 令行 cmd 窗口输入 ipconfig 或者在 Linux 系统中使用 ifconfig 命令就可以查看相关信息了，在这里我 们利用 Qt 做出一个可以查询的界面和功能出来。 Qt 提供了 QHostInfo 和 QNetworkInterface 类可以用于此类信息查询。更多关于 QHostInfo和 QNetworkInterface 的相关函数可以在 Qt 的帮助文档中找到。 123456789101112131415161718192021222324252627//networkhostinfo.proQT += core gui networkgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsCONFIG += c++11# The following define makes your compiler emit warnings if you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain#version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the#APIs deprecated before Qt 6.0.0SOURCES += \\main.cpp \\mainwindow.cppHEADERS += \\mainwindow.h# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target 12345678910111213141516171819202122232425262728293031323334353637383940414243//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QPushButton&gt;#include &lt;QTextBrowser&gt;#include &lt;QVBoxLayout&gt;#include &lt;QHBoxLayout&gt;#include &lt;QTimer&gt;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 点击获取和清空文本按钮 */QPushButton *pushButton[2];/* 文本浏览框用于显示本机的信息 */QTextBrowser *textBrowser;/* 水平 Widget 容器和垂直 Widget 容器*/QWidget *hWidget;QWidget *vWidget;/* 水平布局和垂直布局 */QHBoxLayout *hBoxLayout;QVBoxLayout *vBoxLayout;/* 定时器 */QTimer *timer;/* 获取本机的网络的信息，返回类型是 QString */QString getHostInfo();private slots:/* 定时器槽函数，点击按钮后定时触发 */void timerTimeOut();/* 显示本机信息 */void showHostInfo();/* 启动定时器 */void timerStart();/* 清空 textBrowser 的信息 */void clearHostInfo();&#125;;#endif // MAINWINDOW_H 头文件里主要是声明两个按钮和一个文本浏览框。另外还有一个定时器，声明一些槽函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &lt;QtNetwork/QNetworkInterface&gt;#include &lt;QtNetwork/QHostInfo&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);/* 点击获取本地信息按钮和清空文本按钮 */pushButton[0] = new QPushButton();pushButton[1] = new QPushButton();pushButton[0]-&gt;setText(&quot;获取本机信息&quot;);pushButton[1]-&gt;setText(&quot;清空文本信息&quot;);/* 按钮的大小根据文本自适应，* 注意 setSizePolicy 需要在布局中使用 */pushButton[0]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);pushButton[1]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);/* 水平 Widget 和垂直 Widget 用于添加布局 */hWidget = new QWidget();vWidget = new QWidget();/* 水平布局和垂直布局 */hBoxLayout = new QHBoxLayout();vBoxLayout = new QVBoxLayout();/* 文本浏览框 */textBrowser = new QTextBrowser();/* 添加到水平布局 */hBoxLayout-&gt;addWidget(pushButton[0]);hBoxLayout-&gt;addWidget(pushButton[1]);/* 将水平布局设置为 hWidget 的布局 */hWidget-&gt;setLayout(hBoxLayout);/* 将文本浏览框和 hWidget 添加到垂直布局 */vBoxLayout-&gt;addWidget(textBrowser);vBoxLayout-&gt;addWidget(hWidget);/* 将垂直布局设置为 vWidget 的布局 */vWidget-&gt;setLayout(vBoxLayout);/* 设置 vWidget 为中心部件 */setCentralWidget(vWidget);/* 定时器初始化 */timer = new QTimer();/* 信号槽连接 */connect(pushButton[0], SIGNAL(clicked()),this, SLOT(timerStart()));connect(pushButton[1], SIGNAL(clicked()),this, SLOT(clearHostInfo()));connect(timer, SIGNAL(timeout()),this, SLOT(timerTimeOut()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::timerStart()&#123;/* 清空文本 */textBrowser-&gt;clear();/* 定时 1s */timer-&gt;start(1000);&#125;void MainWindow::timerTimeOut()&#123;/* 显示本机信息 */showHostInfo();/* 停止定时器 */timer-&gt;stop();&#125;QString MainWindow::getHostInfo()&#123;/* 通过 QHostInfo 的 localHostName 函数获取主机名称 */QString str = &quot;主机名称：&quot; + QHostInfo::localHostName() + &quot;\\n&quot;;/* 获取所有的网络接口，* QNetworkInterface 类提供主机的 IP 地址和网络接口的列表 */QList&lt;QNetworkInterface&gt; list = QNetworkInterface::allInterfaces();/* 遍历 list */foreach (QNetworkInterface interface, list) &#123;str+= &quot;网卡设备:&quot; + interface.name() + &quot;\\n&quot;;str+= &quot;MAC 地址:&quot; + interface.hardwareAddress() + &quot;\\n&quot;;/* QNetworkAddressEntry 类存储 IP 地址子网掩码和广播地址 */QList&lt;QNetworkAddressEntry&gt; entryList = interface.addressEntries();/* 遍历 entryList */foreach (QNetworkAddressEntry entry, entryList) &#123;/* 过滤 IPv6 地址，只留下 IPv4 */if (entry.ip().protocol() == QAbstractSocket::IPv4Protocol) &#123;str+= &quot;IP 地址:&quot; + entry.ip().toString() + &quot;\\n&quot;;str+= &quot;子网掩码:&quot; + entry.netmask().toString() + &quot;\\n&quot;;str+= &quot;广播地址:&quot; + entry.broadcast().toString() + &quot;\\n\\n&quot;;&#125;&#125;&#125;/* 返回网络信息 */return str;&#125;void MainWindow::showHostInfo()&#123;/* 获取本机信息后显示到 textBrowser */textBrowser-&gt;insertPlainText(getHostInfo());&#125;void MainWindow::clearHostInfo()&#123;/* 判断 textBrowser 是否为空，如果不为空则清空文本 */if (!textBrowser-&gt;toPlainText().isEmpty())/* 清空文本 */textBrowser-&gt;clear();&#125; 12345第 90~123 行，是本例最重要的代码。第 93 行，通过 QHostInfo 的 localHostName 函数获取主机名称。第 97~98 行，通过 QNetworkInterface::allInterfaces()获取网络接口列表 list 类存储 IP 地址子网掩码和广播地址。如果我们用 qDebug()函数打印出 list，可以发现获取了所有的网络信息。而我们要提取网络里面的网络信息使用 QNetworkAddressEntry。第 106~107 行，使用 QNetworkAddressEntry 从 interface 接口里使用函数addressEntries()，获取所有的条目。就可以使用 QNetworkAddressEntry 的对象 entry 获取 IP地址子网掩码和广播地址。第 110~118 行，因为获取的 entries 在一个 QNetworkInterface 下可能有两个 IP，分别是 ipv4和 ipv6。这里使用 ip().protocol()来判断协议的类型，只留下 ipv4 类型的信息。筛选信息在我们写程序常常需要的。 套接字socket编程 socket概述 接字，用于描述IP地址和端口号 socket时链接运行在网络上的两个程序间的双向通信的端点。 通讯两端都有socket，数据在两个socket之间通过IO进行传输。 套接字是一种特殊的I&#x2F;O接口，在代码内体现为特殊的文件描述符，socket是一种常见的进程间通信。 套接字主要有三种类型： 12345671、流式套接字（SOCK_STREAM）流式套接字提供可靠的，面向连接的通信流，保证数据传输的可靠性和有序性。TCP通信使用该套接字。2、数据报套接字（SOCK_DGRAM）提供不可靠、无连接的通信流，不保证可靠传输、无序。UDP通信使用该套接字。3、原始套接字（SOCK_RAW）允许对底层协议进行访问，功能强大但不方便。 TCP连接的建立：三次握手 TCP连接的释放：四次挥手 socket通信 服务器端将一个套接字绑定到一个特定的端口，并通过这个套接字等待和监听客户的连接请求。 客户端根据服务器所在的主机和端口号发送连接请求。 如果一切正常，服务器接受连接请求，并且获得一个新的绑定到不同端口地址的套接字。 服务器端和客户端通过读写套接字进行通讯。 流程图 服务器端如果需要使用TCP协议创建一个服务器，需要以下步骤： 创建套接字 绑定套接字 设置监听模式 接受客户端的连接请求 接受&#x2F;发送数据 断开连接 创建套接字1234567891011121314151617socket()函数的用法：头文件#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数原型int socket(int domain, int type, int protocol);函数参数domain：选择通信协议，常见的协议：AF_INET：IPv4通信协议AF_INET6：IPv6通信协议AF_UNIX：本地通信type：套接字类型protocol：协议值，通常情况为0函数返回值成功：非负套接字文件描述符失败：-1 12使用markdown嵌入图片 1url https://pic.imgdb.cn/item/65507febc458853aef4c9293.png 1html 1markdownwithlink 1bbcode [img]https://pic.imgdb.cn/item/65507febc458853aef4c9293.png[/img] 1markdown","categories":[{"name":"实训","slug":"实训","permalink":"https://misakivv.github.io/categories/%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"基于MP157开发板的智能家居系统","slug":"基于MP157开发板的智能家居系统 (2)","date":"2023-11-11T15:26:13.963Z","updated":"2023-11-12T07:22:47.891Z","comments":true,"path":"2023/11/11/基于MP157开发板的智能家居系统 (2)/","permalink":"https://misakivv.github.io/2023/11/11/%E5%9F%BA%E4%BA%8EMP157%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F%20(2)/","excerpt":"","text":"QT文件操作1.QFile读写文本提供读取写入文件的接口 文件名通常在构造函数中传递 123456QIDDevice::Readonly:以只读的方式打开文件，用于载入文件QIDDevice::Writeonly:以只写方式打开文件，用于保存文件QIDDevice::ReadWrite:以读写方式打开QIDDevice::Append:以添加模式打开，新写入文件的数据添加到文件末尾QIDDevice::Truncate:以裁取的方式打开文件，文件原有内容会被删除QIDDevice::Text:以文本打开文件 流程：文件–&gt;打开方式–&gt;关闭 1234567891011121314151617181920212223242526272829303132333435363738394041424344//main#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include&lt;QTextEdit&gt;#include&lt;QFile&gt;#include&lt;QVBoxLayout&gt;#include&lt;QHBoxLayout&gt;#include&lt;QPushButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;private: //用于读取文件后显示 QTextEdit *testEdit; QFile file; //QFile 类型对象 QHBoxLayout *hBoxLayout; //水平布局 QVBoxLayout *vBoxLayout; //垂直布局 QWidget *hwidget; //水平布局 widget QWidget *vwideget; //垂直布局 widget QPushButton *openPushButton; //打开文件按钮 QPushButton *closePushButton; //关闭文件按钮 private slots: bool openFile(); //打开文本文件 void closeFile(); //关闭文本文件&#125;;#endif // MAINWINDOW_H 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//mainwindow.h#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120); openPushButton-&gt;setText(&quot;open&quot;); closePushButton-&gt;setText(&quot;close&quot;); closePushButton-&gt;setEnabled(false); hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout); vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout); setCentralWidget(vwideget); connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this); file.setFileName(fileName); if(!file.exists()) return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false; textEdit-&gt;setPlainText(file.readAll()); openPushButton-&gt;setEnabled(false); closePushButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return; QByteArray strBytes = str.toUtf8(); file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); openPushButton-&gt;setEnabled(true); closePushButton-&gt;setEnabled(false);&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot; #include &lt;QFileDialog&gt; //标准通用对话框#include &lt;QDebug&gt; //信息输出头文件MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); //设置窗口的位置与大小//布局设置 textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120);//设置两个按钮的文本 openPushButton-&gt;setText(&quot;打开&quot;); closePushButton-&gt;setText(&quot;关闭&quot;);//设置关闭按钮为不可用属性，需要打开文件才设置为可用属性 closePushButton-&gt;setEnabled(false);//水平布局 hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout);//垂直布局 vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout);//居中 setCentralWidget(vwideget);//信号槽连接 connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this);//获取文件的路径 file.setFileName(fileName); //指向文件 if(!file.exists()) //判断文件是否存在 return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) //以读写的方式打开 return false; textEdit-&gt;setPlainText(file.readAll()); //读取文本到textEdit openPushButton-&gt;setEnabled(false); //设置打开按钮不可用，需要关闭再打开 closePushButton-&gt;setEnabled(true); //设置关闭按钮为可用属性 file.close(); //关闭文件 return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; //检测打开按钮是否可用，不可用时，说明已经打开了文件 QString str = textEdit-&gt;toPlainText(); //获取textEdit的文本内容 if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) //以只读的方式打开 return; QByteArray strBytes = str.toUtf8(); //转换为字节数组 file.write(strBytes,strBytes.length()); //写入文件 textEdit-&gt;clear(); //清空textEdit的显示内容 openPushButton-&gt;setEnabled(true); //重新设置打开何关闭按钮的属性 closePushButton-&gt;setEnabled(false);&#125;&#125; 2.QTextStream读写文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120); openPushButton-&gt;setText(&quot;open&quot;); closePushButton-&gt;setText(&quot;close&quot;); closePushButton-&gt;setEnabled(false); hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout); vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout); setCentralWidget(vwideget); connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this); file.setFileName(fileName); if(!file.exists()) return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false; QTextStream stream(&amp;file); textEdit-&gt;setPlainText(file.readAll()); openPushButton-&gt;setEnabled(false); closePushButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return; QTextStream stream(&amp;file); QString str_1 = textEdit-&gt;toPlainText(); stream &lt;&lt;str_1; //QByteArray strBytes = str.toUtf8(); //file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); openPushButton-&gt;setEnabled(true); closePushButton-&gt;setEnabled(false);&#125;&#125; QT多线程QThread类提供一种独立于平台的方法管理线程。 继承QThread的线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include&lt;QMainWindow&gt;#include&lt;QThread&gt;#include&lt;QDebug&gt;#include&lt;QPushButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass WorkerThread;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;private: WorkerThread *workThread; //声明对象 QPushButton *pushButton; //声明一个按钮，使用此按钮点击后开启线程 private slots: //槽函数，用于接受线程点击后开启线程 void headleResults(const QString &amp;result); void pushButtonClicked(); //点击按钮开启线程&#125;; //新建一个WorkThread类继承于QThreadclass WorkerThread : public QThread&#123; Q_OBJECT //用到信号槽即需要此宏定义 public: WorkerThread(QWidget *parent=nullptr)&#123; Q_UNUSED(parent); &#125; //重写run()方法 void run() override&#123; QString result=&quot;线程开启成功&quot;; sleep(2); //延迟2s emit resultReady(result); //发送结果准备好的信号 &#125; signals: //声明一个信号 void resultReady(const QString &amp;s);&#125;;#endif // MAINWINDOW_H 123456789101112131415161718192021222324252627282930313233343536373839//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); //设置位置与大小 pushButton=new QPushButton(this); //对象实例化 workerThread = new WorkerThread(this); //线程对象实例化//按钮设置大小与文本 pushButton-&gt;resize(100,40); pushButton-&gt;setText(&quot;圆神，启动&quot;);//信号槽连接 connect(workerThread,SIGNAL(resultReady(QString)),this,SLOT(handleResults(QString))); connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));&#125;MainWindow::~MainWindow()&#123; workerThread-&gt;quit(); //进程退出 if(workerThread-&gt;wait(2000))&#123; //阻塞等待2000ms检查一次进程是否已经退出 qDebug()&lt;&lt;&quot;Thread over!&quot;&lt;&lt;endl; &#125; delete ui;&#125;void MainWindow::handleResults(const QString &amp;result)&#123; qDebug()&lt;&lt;result&lt;&lt;endl; //打印线程发送过来的结果&#125;void MainWindow::pushButtonClicked()&#123; if(!workerThread-&gt;isRunning()) //检查线程是否再运行，如果没有则开始运行 workerThread-&gt;start();&#125;","categories":[],"tags":[]},{"title":"","slug":"基于MP157开发板的智能家居系统","date":"2023-11-11T15:22:16.317Z","updated":"2023-11-11T15:23:12.604Z","comments":true,"path":"2023/11/11/基于MP157开发板的智能家居系统/","permalink":"https://misakivv.github.io/2023/11/11/%E5%9F%BA%E4%BA%8EMP157%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1title: 基于MP157开发板的智能家居系统 组名 小组成员 linux、C++、QT QT写界面 MP157开发板 项目功能：环境监测，设备控制 123456789101112131415161718192021222324252627282930313233基于MP157开发板的智能家居系统结合Linux操作系统、C++编程和QT程序开发，可以采用以下总体设计：1. 硬件平台： - MP157开发板：作为嵌入式设备的核心，运行Linux操作系统和应用程序。 - 传感器模块：用于感知环境信息，如温度、湿度、光照等。 - 执行器模块：用于控制家居设备，如灯光、窗帘、空调等。 - 通信模块：用于与其他智能设备或云平台进行通信，如Wi-Fi模块、蓝牙模块等。2. 软件架构： - Linux操作系统：作为底层的操作系统，提供系统资源管理、进程调度和设备驱动等功能。 - C++编程：使用C++语言编写系统的核心逻辑和功能模块。 - QT程序开发：使用QT框架进行图形界面设计，方便用户交互和操作。 - 数据库：使用SQLite或其他轻量级数据库存储设备配置和状态信息。3. 功能模块： - 传感器数据采集：通过传感器模块获取环境信息，如温度、湿度等。 - 控制器驱动：通过执行器模块控制家居设备，如开关灯、调节温度等。 - 通信模块接口：与其他智能设备或云平台进行通信，实现远程控制和监控功能。 - 定时任务管理：设置定时任务，如定时开关灯、定时调整温度等。 - 用户界面：使用QT进行图形界面设计，提供友好的用户交互界面，实现设备配置和状态监控等功能。 - 数据存储和管理：使用数据库存储设备配置、历史数据和用户信息等。4. 工作流程： - 系统启动：开机自启动Linux操作系统和智能家居系统应用程序。 - 数据采集和处理：周期性地获取传感器数据，并根据预设逻辑进行处理和控制。 - 用户交互：通过QT界面，用户可以配置设备参数、查看设备状态，并进行远程控制。 - 通信功能：与其他智能设备或云平台进行通信，实现远程监控和控制。 - 数据存储和管理：将设备配置、历史数据和用户信息存储到数据库中，实现数据的持久化和管理。 - 异常处理：对于异常情况，如传感器故障或通信异常，系统应提供相应的处理机制，如报警或错误提示。以上是基于MP157开发板的智能家居系统的总体设计。具体实现时，可以根据需求进行适当调整和扩展。 &#x2F;********************************************************&#x2F; 123456789101112131415这些控制模块的函数是为了实现智能家居系统中各种设备的控制功能。每个函数对应一个具体的设备操作，如打开或关闭某个LED灯、风扇或蜂鸣器等。下面对这些函数进行逐一解释：1. `led1_on_btnSlot()`和`led1_off_btnSlot()`：这两个函数用于控制LED1灯的开关状态，`led1_on_btnSlot()`用于打开LED1灯，`led1_off_btnSlot()`用于关闭LED1灯。2. `led2_on_btnSlot()`和`led2_off_btnSlot()`：这两个函数用于控制LED2灯的开关状态，`led2_on_btnSlot()`用于打开LED2灯，`led2_off_btnSlot()`用于关闭LED2灯。3. `led3_on_btnSlot()`和`led3_off_btnSlot()`：这两个函数用于控制LED3灯的开关状态，`led3_on_btnSlot()`用于打开LED3灯，`led3_off_btnSlot()`用于关闭LED3灯。4. `fan_on_btnSlot()`和`fan_off_btnSlot()`：这两个函数用于控制风扇的开关状态，`fan_on_btnSlot()`用于打开风扇，`fan_off_btnSlot()`用于关闭风扇。5. `fan_2_btnSlot()`和`fan_3_btnSlot()`：这两个函数用于控制风扇的速度，`fan_2_btnSlot()`用于设置风扇速度为2档，`fan_3_btnSlot()`用于设置风扇速度为3档。6. `beep_on_btnSlot()`和`beep_off_btnSlot()`：这两个函数用于控制蜂鸣器的开关状态，`beep_on_btnSlot()`用于打开蜂鸣器，`beep_off_btnSlot()`用于关闭蜂鸣器。通过这些控制模块的函数，用户可以通过相应的按钮或操作界面来控制各种设备的开关、速度等状态，实现智能家居的远程控制和自动化控制功能。这些函数的实现可以根据具体的硬件和控制逻辑进行调整和扩展。 123湿度（humidity）温度（temperature）光照强度（illumination） &#x2F;########&#x2F; 12345678910111213141516171819202122232425connect(ui-&gt;pushButton_led1_on,SIGNAL(clicked()),this,SLOT(led1_on_btnSlot()));：将pushButton_led1_on按钮的clicked()信号连接到当前类的led1_on_btnSlot()槽函数。connect(ui-&gt;pushButton_led1_off,SIGNAL(clicked()),this,SLOT(led1_off_btnSlot()));：将pushButton_led1_off按钮的clicked()信号连接到当前类的led1_off_btnSlot()槽函数。connect(ui-&gt;pushButton_led2_on,SIGNAL(clicked()),this,SLOT(led2_on_btnSlot()));：将pushButton_led2_on按钮的clicked()信号连接到当前类的led2_on_btnSlot()槽函数。connect(ui-&gt;pushButton_led2_off,SIGNAL(clicked()),this,SLOT(led2_off_btnSlot()));：将pushButton_led2_off按钮的clicked()信号连接到当前类的led2_off_btnSlot()槽函数。connect(ui-&gt;pushButton_led3_on,SIGNAL(clicked()),this,SLOT(led3_on_btnSlot()));：将pushButton_led3_on按钮的clicked()信号连接到当前类的led3_on_btnSlot()槽函数。connect(ui-&gt;pushButton_led3_off,SIGNAL(clicked()),this,SLOT(led3_off_btnSlot()));：将pushButton_led3_off按钮的clicked()信号连接到当前类的led3_off_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_on,SIGNAL(clicked()),this,SLOT(fan_on_btnSlot()));：将pushButton_fan_on按钮的clicked()信号连接到当前类的fan_on_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_off,SIGNAL(clicked()),this,SLOT(fan_off_btnSlot()));：将pushButton_fan_off按钮的clicked()信号连接到当前类的fan_off_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_2,SIGNAL(clicked()),this,SLOT(fan_2_btnSlot()));：将pushButton_fan_2按钮的clicked()信号连接到当前类的fan_2_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_3,SIGNAL(clicked()),this,SLOT(fan_3_btnSlot()));：将pushButton_fan_3按钮的clicked()信号连接到当前类的fan_3_btnSlot()槽函数。connect(ui-&gt;pushButton_beep_on,SIGNAL(clicked()),this,SLOT(beep_on_btnSlot()));：将pushButton_beep_on按钮的clicked()信号连接到当前类的beep_on_btnSlot()槽函数。connect(ui-&gt;pushButton_beep_off,SIGNAL(clicked()),this,SLOT(beep_off_btnSlot()));：将pushButton_beep_off按钮的clicked()信号连接到当前类的beep_off_btnSlot()槽函数。总体来说，这些connect语句建立了按钮点击信号与相应槽函数的关联，使得当用户点击某个按钮时，与之相关的槽函数将被调用，执行特定的操作。这种机制使得界面和功能之间得以有效的交互。 &#x2F;######&#x2F; 12345678910111213led1_on_btnSlot(): 当led1开关按钮被按下时，设置led1开状态的按钮样式并根据板子类型设置对应的LED1亮度。led1_off_btnSlot(): 当led1关闭按钮被按下时，设置led1关状态的按钮样式并根据板子类型设置对应的LED1亮度。led2_on_btnSlot(): 当led2开关按钮被按下时，设置led2开状态的按钮样式并根据板子类型设置对应的LED2亮度。led2_off_btnSlot(): 当led2关闭按钮被按下时，设置led2关状态的按钮样式并根据板子类型设置对应的LED2亮度。led3_on_btnSlot(): 当led3开关按钮被按下时，设置led3开状态的按钮样式并根据板子类型设置对应的LED3亮度。led3_off_btnSlot(): 当led3关闭按钮被按下时，设置led3关状态的按钮样式并根据板子类型设置对应的LED3亮度。fan_on_btnSlot(): 当风扇开关按钮被按下时，设置风扇开状态的按钮样式并根据板子类型设置对应的风扇转速。fan_off_btnSlot(): 当风扇关闭按钮被按下时，设置风扇关状态的按钮样式并根据板子类型设置对应的风扇转速。fan_2_btnSlot(): 当风扇2档按钮被按下时，设置风扇2档状态的按钮样式并根据板子类型设置对应的风扇转速。fan_3_btnSlot(): 当风扇3档按钮被按下时，设置风扇3档状态的按钮样式并根据板子类型设置对应的风扇转速。beep_on_btnSlot(): 当蜂鸣器开关按钮被按下时，设置蜂鸣器开状态的按钮样式并执行响铃操作。beep_off_btnSlot(): 当蜂鸣器关闭按钮被按下时，设置蜂鸣器关状态的按钮样式并停止响铃操作。这些槽函数通过修改界面按钮的样式并调用特定的系统命令或函数来控制硬件设备（如LED、风扇、蜂鸣器）的状态，实现了用户界面与硬件设备的交互控制。 123456789 再添加库文件引用：win32:CONFIG(release, debug|release): LIBS += -L$$PWD/lib/ -lQt5Mqttelse:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/lib/ -lQt5Mqttd添加 include 文件的引用：INCLUDEPATH += $$PWD/includeDEPENDPATH += $$PWD/include 1234567891011在本次MP157开发板的智能家居系统实训中，我担任小组长一职，全程负责协调小组成员完成任务，经历了一系列的规划、开发、调试和测试阶段。通过这次实训，我收获颇丰，不仅深化了对嵌入式系统和物联网技术的理解，还提升了团队协作和项目管理的能力。首先，我学到了如何有效地规划和组织项目。在项目开始之前，我与小组成员共同制定了详细的计划和任务分配，明确了每个人的责任和目标。这有助于确保项目有序进行，每个任务都能按时完成。同时，我学到了灵活应对计划变动的能力，随时调整团队的工作重心，以应对新的挑战和需求。其次，通过实际操作，我加深了对MP157开发板的理解和应用。在项目中，我们需要与传感器、执行器、网络模块等硬件设备进行交互，通过C++/Qt编程实现智能家居系统的各项功能，如灯光控制、温度监测、远程控制等。这让我更加熟悉嵌入式开发的流程，提高了代码调试和优化的能力。协调小组成员也是我在这次实训中的一项重要经验。通过定期的小组会议，我能够了解每个成员的工作进展、遇到的问题，并及时提供帮助和支持。在面对团队内部的协作问题时，我学到了沟通和解决冲突的技巧，使整个团队能够更加紧密地合作。在这个过程中，我还学到了如何有效地进行团队管理。合理分配任务，鼓励团队成员分享经验和思路，及时解决困难，都是成功管理一个小组的关键。通过这次实训，我更加明确了领导者在项目中的重要性，也懂得了在团队中发挥每个成员的优势，使整个团队更具创造力和执行力。总的来说，这次MP157开发板的智能家居系统实训为我提供了一个全面锻炼技术和管理能力的机会。我不仅掌握了更多的技术知识，还提高了团队协作和项目管理的实际能力。这将对我的未来职业发展产生积极的影响，使我更好地适应和应对复杂的工程项目。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-11T14:52:18.125Z","updated":"2023-11-11T14:52:18.125Z","comments":true,"path":"2023/11/11/hello-world/","permalink":"https://misakivv.github.io/2023/11/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"实训","slug":"实训","permalink":"https://misakivv.github.io/categories/%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}