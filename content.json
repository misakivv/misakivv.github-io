{"meta":{"title":"my blog","subtitle":"","description":"blog","author":"John Doe","url":"https://misakivv.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2023-11-14T14:50:57.000Z","updated":"2023-11-14T14:52:06.400Z","comments":false,"path":"/404.html","permalink":"https://misakivv.github.io/404.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-11-14T14:44:59.448Z","updated":"2023-11-14T14:44:59.448Z","comments":true,"path":"categories/index.html","permalink":"https://misakivv.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-11-14T14:44:37.336Z","updated":"2023-11-14T14:44:37.336Z","comments":true,"path":"tags/index.html","permalink":"https://misakivv.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-14T14:45:26.208Z","updated":"2023-11-14T14:45:26.208Z","comments":true,"path":"about/index.html","permalink":"https://misakivv.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-11-12T02:02:15.000Z","updated":"2023-11-12T02:34:51.124Z","comments":true,"path":"friends/index.html","permalink":"https://misakivv.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"嵌入式Day11","slug":"嵌入式Day11","date":"2023-11-18T08:57:44.000Z","updated":"2023-11-18T09:11:16.221Z","comments":true,"path":"2023/11/18/嵌入式Day11/","permalink":"https://misakivv.github.io/2023/11/18/%E5%B5%8C%E5%85%A5%E5%BC%8FDay11/","excerpt":"","text":"基于MP157开发板的智能家居系统STM32CubeProgrammer 安装获得STM32CubeProgrammer压缩包，创建STM32CubeProgrammer文件夹，解压完成后获得如下文件 双击“SetupSTM32CubeProgrammer-2.4.0.exe”允许安装向导。 点击“Next” 点击“Next” 点击“I accept the terms of this license agreement” 勾选 “I have read and understood the ST Privacy Policy and ST terms of Use” 这里选择安装路径，用户可以自行指定。点击 Next 之后会提示，将要创建一个安装目录。 勾选 STM32TrustePackageCreator 选项 Next 之后会进程序安装。 在安装的过程中会弹出如下界面，安装相关的驱动程序。点击“下一步” 程序将会自动安装所需的驱动程序，安装完成后会弹出如下界面。 点击“完成” 切换到“STM32CubeProgrammer”界面后点击“Next”，创建桌面快捷键。 安装完成界面 出现上述界面后点击“Done”。至此 STM32CubeProgrammer 就安装完成了。 镜像烧写获取镜像系统 镜像烧写将拨码开关拨至【000】进行程序烧写 打开【STM32CubeProgrammer】软件，点击【+】，点击【open file】 注：烧写脚本 Flashlayout 需要和 tf-a、u-boot、sdcard.img 在同一个文件夹下 找到存放镜像的文件夹 检查路径是否为烧录配置文件所在的路径。需要再同一路径 如果在打开软件之前开发板已经处于上电状则可以看到右上角的 USB 设备 出现 USB1 端口后点击左上角的【Connect】按钮进行连接。 连接成功后上方原来为【Not connected】字样变为【Connect】 点击界面右上角的【Download】按钮进行烧录。 烧写成功后会出现如下提示 启动系统拨码选择通过 STM32CubeProgrammer 方式烧录 emmc 镜像就完成后，就可以通过改变拨码开关为【010】来进 行系统的启动。 打开串口启动win+r 输入devmgmt.msc打开设备管理器 打开串口工具选择自己电脑显示 COM 口连接启动开发板 打开shell7，连接协议选择SERIAL 在串口中选择自己电脑上查到的串口号，波特率为115200，数据位为8，停止位为1保持默认。点击连接。 如果shell页面卡住，可以按主板电源附近的复位键即可继续 注意，由于显示屏为5寸，所以在Select the boot mode中选择5 启动登录密码为root，启动成功后会进入buildroot系统 取消默认桌面因为我们生成的默认桌面会影响软键盘的使用，所以我们在做实验前先将默认桌面退出。 在&#x2F;usr&#x2F;share&#x2F;applications&#x2F;desktopsystem 路径下有一个 desktopstart.sh 的脚本文件，我们打开这个脚本文 件。 1vi desktopstart.sh 将下图中的&#x2F;usr&#x2F;share&#x2F;applications&#x2F;desktopsystem&#x2F;qt5desktop -platform linuxfb:rotation&#x3D;0 这句代码用#注 释掉，然后保存退出。再次启动就不会有默认桌面了。 1234567#!/bin/shexport QTDIR=/usr/lib/qt export QT_QPA_PLATFORM_PLUGIN_PATH=$QTDIR/pluginsexport $(dbus-launch)#/usr/share/applications/desktopsystem/qt5desktop -platform linuxfb:rotation=0 项目功能展示系统启动成功后进入到应用程序目录 1root@buildroot:# cd /usr/share/applications/qt5example 其中 qt5homeautomation 是 7 寸屏的可执行文件，qt5homeautomation-mipi050 是 5 寸屏的可执行文件 在五寸屏下命令rotation反转1并添加下面两个环境变量： 12root@buildroot:# export QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS=/dev/input/event2:rotate=270root@buildroot:# export QT_QPA_GENERIC_PLUGINS=evdevtouch:/dev/input/event2 最后执行 1root@buildroot:#./qt5homeautomation-mipi050 -platform linuxfb:rotation=1 效果展示 部分代码1234567891011/* 读取湿度数据 */read_sysfs_int(device1, &quot;in_humidityrelative_raw&quot;, &amp;hum_raw); // 读取湿度原始值read_sysfs_int(device1, &quot;in_humidityrelative_offset&quot;, &amp;hum_offset); // 读取湿度偏移值read_sysfs_float(device1, &quot;in_humidityrelative_scale&quot;, &amp;hum_scale); // 读取湿度缩放系数hum_float = (hum_raw + hum_offset) * hum_scale / 1000; // 计算实际湿度值hum = QString::number(hum_float, &#x27;f&#x27;, 2); // 转换为字符串形式 123456789101112(fscanf(sysfsfp, &quot;%d\\n&quot;, val) != 1)&#123;ret = errno ? -errno : -ENODATA;if (fclose(sysfsfp))perror(&quot;read_sysfs_float(): Failed to close dir&quot;);goto error;&#125;if (fclose(sysfsfp))ret = -errno;error:return ret;&#125; 12connect(&amp;thread_collentdata,SIGNAL(send(QString,QString,QString)),this,SLOT( set_humAdtemAdill(QString,QString,QString))); 123456[root@buildroot]:~# echo 1 &gt; /sys/class/leds/user1/brightness //LED1灯亮[root@buildroot]:~# echo 0 &gt; /sys/class/leds/ user1/brightness //LED1灯灭[root@buildroot]:~# echo 1 &gt; /sys/class/leds/ user2/brightness //LED2灯亮[root@buildroot]:~# echo 0 &gt; /sys/class/leds/ user2/brightness //LED2灯灭[root@buildroot]:~# echo 1 &gt; /sys/class/leds/ user3/brightness //LED3灯亮[root@buildroot]:~# echo 0 &gt; /sys/class/leds/ user3/brightness //LED3灯灭 123456789fd = open(&quot;/dev/input/by-path/platform-beeper-event&quot;, O_RDWR); // 打开设备文件 &quot;/dev/input/by-path/platform-beeper-event&quot;，以可读可写模式event.type = EV_SND; // 设置事件类型为声音事件event.code = SND_TONE; // 设置事件代码为音调事件event.value = 1000; // 设置事件的值为1000（音调值）time.tv_sec = 1; // 设置时间的秒数为1秒time.tv_usec = 0; // 设置时间的微秒数为0event.time = time; // 设置事件的时间为定义的时间结构体","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"嵌入式Day10","slug":"嵌入式Day10","date":"2023-11-18T08:46:58.000Z","updated":"2023-11-18T08:50:46.574Z","comments":true,"path":"2023/11/18/嵌入式Day10/","permalink":"https://misakivv.github.io/2023/11/18/%E5%B5%8C%E5%85%A5%E5%BC%8FDay10/","excerpt":"","text":"QT多线程02继承QObject的线程 继承QObject类更加灵活。它通过 QObject::moveToThread()方法将它移到一个 QThread 线程里 执行。那么可以通过主线程发送信号去调用 QThread 线程的方法如上图的 fun4()，fun5()等等。这些方 法都是在 QThread 线程里执行的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;#include &lt;QMutexLocker&gt;#include &lt;QMutex&gt;/* 工人类 */class Worker;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 开始线程按钮 */QPushButton *pushButton1;QPushButton *pushButton2;/* 全局线程 */QThread workerThread;/* 工人类 */Worker *worker;private slots:/* 按钮 1 点击开启线程 */void pushButton1Clicked();/* 按钮 2 点击打断线程 */void pushButton2Clicked();/* 用于接收工人是否在工作的信号 */void handleResults(const QString &amp;);signals:/* 工人开始工作（做些耗时的操作 ） */void startWork(const QString &amp;);&#125;;/* Worker 类，这个类声明了 doWork1 函数，将整个 Worker 类移至线程 workerThread*/class Worker : public QObject&#123;Q_OBJECTprivate:/* 互斥锁 */QMutex lock;/* 标志位 */bool isCanRun;public slots:/* 耗时的工作都放在槽函数下，工人可以有多份不同的工作，但是每次只能去做一份 */void doWork1(const QString &amp;parameter) &#123;/* 标志位为真 */isCanRun = true;/* 死循环 */while (1) &#123;/* 此&#123;&#125;作用是 QMutexLocker 与 lock 的作用范围，获取锁后，* 运行完成后即解锁 */&#123;QMutexLocker locker(&amp;lock);/* 如果标志位不为真 */if (!isCanRun) &#123;/* 跳出循环 */break;&#125;&#125;/* 使用 QThread 里的延时函数，当作一个普通延时 */QThread::sleep(2);emit resultReady(parameter + &quot;doWork1 函数&quot;);&#125;/* doWork1 运行完成，发送信号 */emit resultReady(&quot;打断 doWork1 函数&quot;);&#125;// void doWork2();...public:/* 打断线程（注意此方法不能放在槽函数下） */void stopWork() &#123;qDebug()&lt;&lt;&quot;打断线程&quot;&lt;&lt;endl;/* 获取锁后，运行完成后即解锁 */QMutexLocker locker(&amp;lock);isCanRun = false;&#125;signals:/* 工人工作函数状态的信号 */void resultReady(const QString &amp;result);&#125;;#endif // MAINWINDOW_H 第 51105 行，声明一个 Worker 的类继承 QObject 类，这里是参考 Qt 的 QThread 类的帮助文档的 写法。 第 6288 行，我们把耗时的工作都放于槽函数下。工人可以有不同的工作，但是每次只能去做一份。 这里不同于继承 QThread 类的线程 run()，继承 QThread 的类只有 run()在新线程里。而继承 QObject 的类，使用 moveToThread()可以把整个继承的 QObject 类移至线程里执行，所以可以有 doWork1(),doWork2…等等耗时的操作，但是这些耗时的操作都应该作为槽函数，由主线程去调用。 第 67~80 行，进入循环后使用互拆锁判断 isCanRun 变量的状态，为假即跳出 while 循环，直到 doWork1 结束。注意，虽然 doWork1 结束了，但是线程并没有退出（结束）。因为我们把这个类移到 线程里了，直到这个类被销毁。或者使用 quit()和 exit()退出线程才真正的结束！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475mainwindow.cpp#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置显示位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);pushButton1 = new QPushButton(this);pushButton2 = new QPushButton(this);/* 设置按钮的位置大小 */pushButton1-&gt;setGeometry(300, 200, 80, 40);pushButton2-&gt;setGeometry(400, 200, 80, 40);/* 设置两个按钮的文本 */pushButton1-&gt;setText(&quot;开启线程&quot;);pushButton2-&gt;setText(&quot;打断线程&quot;);worker = new Worker;/* 将 worker 类移至线程 workerThread */worker-&gt;moveToThread(&amp;workerThread);/* 信号槽连接 *//* 线程完成销毁对象 */connect(&amp;workerThread, SIGNAL(finished()),worker, SLOT(deleteLater()));connect(&amp;workerThread, SIGNAL(finished()),&amp;workerThread, SLOT(deleteLater()));/* 发送开始工作的信号，开始工作 */connect(this, SIGNAL(startWork(QString)),worker, SLOT(doWork1(QString)));/* 接收到 worker 发送过来的信号 */connect(worker, SIGNAL(resultReady(QString)),this, SLOT(handleResults(QString)));/* 点击按钮开始线程 */connect(pushButton1, SIGNAL(clicked()),this, SLOT(pushButton1Clicked()));/* 点击按钮打断线程 */connect(pushButton2, SIGNAL(clicked()),this, SLOT(pushButton2Clicked()));&#125;MainWindow::~MainWindow()&#123;/* 打断线程再退出 */worker-&gt;stopWork();workerThread.quit();/* 阻塞线程 2000ms，判断线程是否结束 */if (workerThread.wait(2000)) &#123;qDebug()&lt;&lt;&quot;线程结束&quot;&lt;&lt;endl;&#125;&#125;void MainWindow::pushButton1Clicked()&#123;/* 字符串常量 */const QString str = &quot;正在运行&quot;;/* 判断线程是否在运行 */if(!workerThread.isRunning()) &#123;/* 开启线程 */workerThread.start();&#125;/* 发送正在运行的信号，线程收到信号后执行后返回线程耗时函数 + 此字符串 */emit this-&gt;startWork(str);&#125;void MainWindow::pushButton2Clicked()&#123;/* 如果线程在运行 */if(workerThread.isRunning()) &#123;/* 停止耗时工作，跳出耗时工作的循环 */worker-&gt;stopWork();&#125;&#125;void MainWindow::handleResults(const QString &amp; results)&#123;/* 打印线程的状态 */qDebug()&lt;&lt;&quot;线程的状态：&quot;&lt;&lt;results&lt;&lt;endl;&#125; 第 20 行，工人类实例化。继承 QObject 的多线程类不能指定父对象。 第 24 行，工人类实例化后，工人类将自己移至 workerThread 线程里执行。 第 29~32 行，线程结束后，我们需要使用 deleteLater 来销毁 worker 对象和 workerThread对象分配 的内存。deleteLater 会确认消息循环中没有这两个线程的对象后销毁。 网络编程1234567Qt网络模块为我们提供了编写 TCP / IP 客户端和服务器的类。它提供了较低级别的类，例如代表低级网络概念的 QTcpSocket，QTcpServer 和 QUdpSocket，以及诸如 QNetworkRequest，QNetworkReply和 QNetworkAccessManager 之类的高级类来执行使用通用协议的网络操作。 它还提供了诸如QNetworkConfiguration，QNetworkConfigurationManager和QNetworkSession等类，实现承载管理。想要在程序中使用 Qt 网络模块，我们需要在 pro 项目配置文件里增加下面的一条语句。QT += network 获取本机的网络信息为什么先写获取本机网络信息的内容呢？在建立网络通信之前我们至少得获取对方的 IP地址。在网络应 用中，经常需要用到本机的主机名、IP 地址、MAC 地址等网络信息，通常通在 Windows 通过调出命 令行 cmd 窗口输入 ipconfig 或者在 Linux 系统中使用 ifconfig 命令就可以查看相关信息了，在这里我 们利用 Qt 做出一个可以查询的界面和功能出来。 Qt 提供了 QHostInfo 和 QNetworkInterface 类可以用于此类信息查询。更多关于 QHostInfo和 QNetworkInterface 的相关函数可以在 Qt 的帮助文档中找到。 123456789101112131415161718192021222324252627//networkhostinfo.proQT += core gui networkgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsCONFIG += c++11# The following define makes your compiler emit warnings if you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain#version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the#APIs deprecated before Qt 6.0.0SOURCES += \\main.cpp \\mainwindow.cppHEADERS += \\mainwindow.h# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target 12345678910111213141516171819202122232425262728293031323334353637383940414243//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QPushButton&gt;#include &lt;QTextBrowser&gt;#include &lt;QVBoxLayout&gt;#include &lt;QHBoxLayout&gt;#include &lt;QTimer&gt;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 点击获取和清空文本按钮 */QPushButton *pushButton[2];/* 文本浏览框用于显示本机的信息 */QTextBrowser *textBrowser;/* 水平 Widget 容器和垂直 Widget 容器*/QWidget *hWidget;QWidget *vWidget;/* 水平布局和垂直布局 */QHBoxLayout *hBoxLayout;QVBoxLayout *vBoxLayout;/* 定时器 */QTimer *timer;/* 获取本机的网络的信息，返回类型是 QString */QString getHostInfo();private slots:/* 定时器槽函数，点击按钮后定时触发 */void timerTimeOut();/* 显示本机信息 */void showHostInfo();/* 启动定时器 */void timerStart();/* 清空 textBrowser 的信息 */void clearHostInfo();&#125;;#endif // MAINWINDOW_H 头文件里主要是声明两个按钮和一个文本浏览框。另外还有一个定时器，声明一些槽函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &lt;QtNetwork/QNetworkInterface&gt;#include &lt;QtNetwork/QHostInfo&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);/* 点击获取本地信息按钮和清空文本按钮 */pushButton[0] = new QPushButton();pushButton[1] = new QPushButton();pushButton[0]-&gt;setText(&quot;获取本机信息&quot;);pushButton[1]-&gt;setText(&quot;清空文本信息&quot;);/* 按钮的大小根据文本自适应，* 注意 setSizePolicy 需要在布局中使用 */pushButton[0]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);pushButton[1]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);/* 水平 Widget 和垂直 Widget 用于添加布局 */hWidget = new QWidget();vWidget = new QWidget();/* 水平布局和垂直布局 */hBoxLayout = new QHBoxLayout();vBoxLayout = new QVBoxLayout();/* 文本浏览框 */textBrowser = new QTextBrowser();/* 添加到水平布局 */hBoxLayout-&gt;addWidget(pushButton[0]);hBoxLayout-&gt;addWidget(pushButton[1]);/* 将水平布局设置为 hWidget 的布局 */hWidget-&gt;setLayout(hBoxLayout);/* 将文本浏览框和 hWidget 添加到垂直布局 */vBoxLayout-&gt;addWidget(textBrowser);vBoxLayout-&gt;addWidget(hWidget);/* 将垂直布局设置为 vWidget 的布局 */vWidget-&gt;setLayout(vBoxLayout);/* 设置 vWidget 为中心部件 */setCentralWidget(vWidget);/* 定时器初始化 */timer = new QTimer();/* 信号槽连接 */connect(pushButton[0], SIGNAL(clicked()),this, SLOT(timerStart()));connect(pushButton[1], SIGNAL(clicked()),this, SLOT(clearHostInfo()));connect(timer, SIGNAL(timeout()),this, SLOT(timerTimeOut()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::timerStart()&#123;/* 清空文本 */textBrowser-&gt;clear();/* 定时 1s */timer-&gt;start(1000);&#125;void MainWindow::timerTimeOut()&#123;/* 显示本机信息 */showHostInfo();/* 停止定时器 */timer-&gt;stop();&#125;QString MainWindow::getHostInfo()&#123;/* 通过 QHostInfo 的 localHostName 函数获取主机名称 */QString str = &quot;主机名称：&quot; + QHostInfo::localHostName() + &quot;\\n&quot;;/* 获取所有的网络接口，* QNetworkInterface 类提供主机的 IP 地址和网络接口的列表 */QList&lt;QNetworkInterface&gt; list = QNetworkInterface::allInterfaces();/* 遍历 list */foreach (QNetworkInterface interface, list) &#123;str+= &quot;网卡设备:&quot; + interface.name() + &quot;\\n&quot;;str+= &quot;MAC 地址:&quot; + interface.hardwareAddress() + &quot;\\n&quot;;/* QNetworkAddressEntry 类存储 IP 地址子网掩码和广播地址 */QList&lt;QNetworkAddressEntry&gt; entryList = interface.addressEntries();/* 遍历 entryList */foreach (QNetworkAddressEntry entry, entryList) &#123;/* 过滤 IPv6 地址，只留下 IPv4 */if (entry.ip().protocol() == QAbstractSocket::IPv4Protocol) &#123;str+= &quot;IP 地址:&quot; + entry.ip().toString() + &quot;\\n&quot;;str+= &quot;子网掩码:&quot; + entry.netmask().toString() + &quot;\\n&quot;;str+= &quot;广播地址:&quot; + entry.broadcast().toString() + &quot;\\n\\n&quot;;&#125;&#125;&#125;/* 返回网络信息 */return str;&#125;void MainWindow::showHostInfo()&#123;/* 获取本机信息后显示到 textBrowser */textBrowser-&gt;insertPlainText(getHostInfo());&#125;void MainWindow::clearHostInfo()&#123;/* 判断 textBrowser 是否为空，如果不为空则清空文本 */if (!textBrowser-&gt;toPlainText().isEmpty())/* 清空文本 */textBrowser-&gt;clear();&#125; 12345第 90~123 行，是本例最重要的代码。第 93 行，通过 QHostInfo 的 localHostName 函数获取主机名称。第 97~98 行，通过 QNetworkInterface::allInterfaces()获取网络接口列表 list 类存储 IP 地址子网掩码和广播地址。如果我们用 qDebug()函数打印出 list，可以发现获取了所有的网络信息。而我们要提取网络里面的网络信息使用 QNetworkAddressEntry。第 106~107 行，使用 QNetworkAddressEntry 从 interface 接口里使用函数addressEntries()，获取所有的条目。就可以使用 QNetworkAddressEntry 的对象 entry 获取 IP地址子网掩码和广播地址。第 110~118 行，因为获取的 entries 在一个 QNetworkInterface 下可能有两个 IP，分别是 ipv4和 ipv6。这里使用 ip().protocol()来判断协议的类型，只留下 ipv4 类型的信息。筛选信息在我们写程序常常需要的。 套接字socket编程 socket概述 接字，用于描述IP地址和端口号 socket时链接运行在网络上的两个程序间的双向通信的端点。 通讯两端都有socket，数据在两个socket之间通过IO进行传输。 套接字是一种特殊的I&#x2F;O接口，在代码内体现为特殊的文件描述符，socket是一种常见的进程间通信。 套接字主要有三种类型： 12345671、流式套接字（SOCK_STREAM）流式套接字提供可靠的，面向连接的通信流，保证数据传输的可靠性和有序性。TCP通信使用该套接字。2、数据报套接字（SOCK_DGRAM）提供不可靠、无连接的通信流，不保证可靠传输、无序。UDP通信使用该套接字。3、原始套接字（SOCK_RAW）允许对底层协议进行访问，功能强大但不方便。 TCP连接的建立：三次握手 TCP连接的释放：四次挥手 socket通信 服务器端将一个套接字绑定到一个特定的端口，并通过这个套接字等待和监听客户的连接请求。 客户端根据服务器所在的主机和端口号发送连接请求。 如果一切正常，服务器接受连接请求，并且获得一个新的绑定到不同端口地址的套接字。 服务器端和客户端通过读写套接字进行通讯。 流程图 服务器端如果需要使用TCP协议创建一个服务器，需要以下步骤： 创建套接字 绑定套接字 设置监听模式 接受客户端的连接请求 接受&#x2F;发送数据 断开连接 创建套接字 1234567891011121314151617socket()函数的用法：头文件#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数原型int socket(int domain, int type, int protocol);函数参数domain：选择通信协议，常见的协议：AF_INET：IPv4通信协议AF_INET6：IPv6通信协议AF_UNIX：本地通信type：套接字类型protocol：协议值，通常情况为0函数返回值成功：非负套接字文件描述符失败：-1","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://misakivv.github.io/tags/Qt/"}]},{"title":"嵌入式Day9","slug":"嵌入式Day9","date":"2023-11-18T00:55:33.000Z","updated":"2023-11-18T01:56:52.800Z","comments":true,"path":"2023/11/18/嵌入式Day9/","permalink":"https://misakivv.github.io/2023/11/18/%E5%B5%8C%E5%85%A5%E5%BC%8FDay9/","excerpt":"","text":"QT文件操作QFile读写文本提供读取写入文件的接口 文件名通常在构造函数中传递 123456QIDDevice::Readonly:以只读的方式打开文件，用于载入文件QIDDevice::Writeonly:以只写方式打开文件，用于保存文件QIDDevice::ReadWrite:以读写方式打开QIDDevice::Append:以添加模式打开，新写入文件的数据添加到文件末尾QIDDevice::Truncate:以裁取的方式打开文件，文件原有内容会被删除QIDDevice::Text:以文本打开文件 流程：文件–&gt;打开方式–&gt;关闭 1234567891011121314151617181920212223242526272829303132333435363738394041424344//main#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include&lt;QTextEdit&gt;#include&lt;QFile&gt;#include&lt;QVBoxLayout&gt;#include&lt;QHBoxLayout&gt;#include&lt;QPushButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;private: //用于读取文件后显示 QTextEdit *testEdit; QFile file; //QFile 类型对象 QHBoxLayout *hBoxLayout; //水平布局 QVBoxLayout *vBoxLayout; //垂直布局 QWidget *hwidget; //水平布局 widget QWidget *vwideget; //垂直布局 widget QPushButton *openPushButton; //打开文件按钮 QPushButton *closePushButton; //关闭文件按钮 private slots: bool openFile(); //打开文本文件 void closeFile(); //关闭文本文件&#125;;#endif // MAINWINDOW_H 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//mainwindow.h#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120); openPushButton-&gt;setText(&quot;open&quot;); closePushButton-&gt;setText(&quot;close&quot;); closePushButton-&gt;setEnabled(false); hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout); vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout); setCentralWidget(vwideget); connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this); file.setFileName(fileName); if(!file.exists()) return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false; textEdit-&gt;setPlainText(file.readAll()); openPushButton-&gt;setEnabled(false); closePushButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return; QByteArray strBytes = str.toUtf8(); file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); openPushButton-&gt;setEnabled(true); closePushButton-&gt;setEnabled(false);&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot; #include &lt;QFileDialog&gt; //标准通用对话框#include &lt;QDebug&gt; //信息输出头文件MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); //设置窗口的位置与大小//布局设置 textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120);//设置两个按钮的文本 openPushButton-&gt;setText(&quot;打开&quot;); closePushButton-&gt;setText(&quot;关闭&quot;);//设置关闭按钮为不可用属性，需要打开文件才设置为可用属性 closePushButton-&gt;setEnabled(false);//水平布局 hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout);//垂直布局 vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout);//居中 setCentralWidget(vwideget);//信号槽连接 connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this);//获取文件的路径 file.setFileName(fileName); //指向文件 if(!file.exists()) //判断文件是否存在 return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) //以读写的方式打开 return false; textEdit-&gt;setPlainText(file.readAll()); //读取文本到textEdit openPushButton-&gt;setEnabled(false); //设置打开按钮不可用，需要关闭再打开 closePushButton-&gt;setEnabled(true); //设置关闭按钮为可用属性 file.close(); //关闭文件 return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; //检测打开按钮是否可用，不可用时，说明已经打开了文件 QString str = textEdit-&gt;toPlainText(); //获取textEdit的文本内容 if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) //以只读的方式打开 return; QByteArray strBytes = str.toUtf8(); //转换为字节数组 file.write(strBytes,strBytes.length()); //写入文件 textEdit-&gt;clear(); //清空textEdit的显示内容 openPushButton-&gt;setEnabled(true); //重新设置打开何关闭按钮的属性 closePushButton-&gt;setEnabled(false);&#125;&#125; 2.QTextStream读写文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120); openPushButton-&gt;setText(&quot;open&quot;); closePushButton-&gt;setText(&quot;close&quot;); closePushButton-&gt;setEnabled(false); hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout); vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout); setCentralWidget(vwideget); connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this); file.setFileName(fileName); if(!file.exists()) return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false; QTextStream stream(&amp;file); textEdit-&gt;setPlainText(file.readAll()); openPushButton-&gt;setEnabled(false); closePushButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return; QTextStream stream(&amp;file); QString str_1 = textEdit-&gt;toPlainText(); stream &lt;&lt;str_1; //QByteArray strBytes = str.toUtf8(); //file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); openPushButton-&gt;setEnabled(true); closePushButton-&gt;setEnabled(false);&#125;&#125; QT多线程QThread类提供一种独立于平台的方法管理线程。 继承QThread的线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include&lt;QMainWindow&gt;#include&lt;QThread&gt;#include&lt;QDebug&gt;#include&lt;QPushButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass WorkerThread;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;private: WorkerThread *workThread; //声明对象 QPushButton *pushButton; //声明一个按钮，使用此按钮点击后开启线程 private slots: //槽函数，用于接受线程点击后开启线程 void headleResults(const QString &amp;result); void pushButtonClicked(); //点击按钮开启线程&#125;; //新建一个WorkThread类继承于QThreadclass WorkerThread : public QThread&#123; Q_OBJECT //用到信号槽即需要此宏定义 public: WorkerThread(QWidget *parent=nullptr)&#123; Q_UNUSED(parent); &#125; //重写run()方法 void run() override&#123; QString result=&quot;线程开启成功&quot;; sleep(2); //延迟2s emit resultReady(result); //发送结果准备好的信号 &#125; signals: //声明一个信号 void resultReady(const QString &amp;s);&#125;;#endif // MAINWINDOW_H 123456789101112131415161718192021222324252627282930313233343536373839//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); //设置位置与大小 pushButton=new QPushButton(this); //对象实例化 workerThread = new WorkerThread(this); //线程对象实例化//按钮设置大小与文本 pushButton-&gt;resize(100,40); pushButton-&gt;setText(&quot;圆神，启动&quot;);//信号槽连接 connect(workerThread,SIGNAL(resultReady(QString)),this,SLOT(handleResults(QString))); connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));&#125;MainWindow::~MainWindow()&#123; workerThread-&gt;quit(); //进程退出 if(workerThread-&gt;wait(2000))&#123; //阻塞等待2000ms检查一次进程是否已经退出 qDebug()&lt;&lt;&quot;Thread over!&quot;&lt;&lt;endl; &#125; delete ui;&#125;void MainWindow::handleResults(const QString &amp;result)&#123; qDebug()&lt;&lt;result&lt;&lt;endl; //打印线程发送过来的结果&#125;void MainWindow::pushButtonClicked()&#123; if(!workerThread-&gt;isRunning()) //检查线程是否再运行，如果没有则开始运行 workerThread-&gt;start();&#125;","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://misakivv.github.io/tags/Qt/"}]},{"title":"嵌入式Day8","slug":"嵌入式Day8","date":"2023-11-16T15:27:14.000Z","updated":"2023-11-16T15:32:44.551Z","comments":true,"path":"2023/11/16/嵌入式Day8/","permalink":"https://misakivv.github.io/2023/11/16/%E5%B5%8C%E5%85%A5%E5%BC%8FDay8/","excerpt":"","text":"简历格式招聘流程 简历筛选 初试&#x2F;复试&#x2F;终试 录用 职位划分 HR人事（基本信息，职业素养，沟通交流，薪资待遇） 技术人员（专业技能素养） 部门领导（综合能力，抗压能力） 简历筛选原则123451、简历布局（10-30s）2、个人亮点（业绩能力、项目经验、获奖证书、专业技能）3、职位匹配度（求职意向、能力匹配度） 简历核心内容 个人信息 求职意向（软件工程师、内核开发工程师、网络工程师、驱动开发工程师、系统工程师、产品经理） 教育背景（最高学历写最上面、学校名称单独成行 写全称、专业课程 挑选重点 岗位相关 培训经历） 专业技能 项目经验 基本信息必须填写 姓名 联系方式 邮箱 选择填写 政治面貌 籍贯 出生年月 照片 英语等级 地址 民族 性别 个人爱好 一定不写 薪资 写 背景 做法 结果 专业技能 精通 熟悉 了解","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"简历格式","slug":"简历格式","permalink":"https://misakivv.github.io/tags/%E7%AE%80%E5%8E%86%E6%A0%BC%E5%BC%8F/"}]},{"title":"嵌入式Day5","slug":"嵌入式Day5","date":"2023-11-16T15:19:01.000Z","updated":"2023-11-16T15:23:55.694Z","comments":true,"path":"2023/11/16/嵌入式Day5/","permalink":"https://misakivv.github.io/2023/11/16/%E5%B5%8C%E5%85%A5%E5%BC%8FDay5/","excerpt":"","text":"C++基础03this 指针1一个类的不同对象在调用自己的成员函数时，其实他们调用的是同一段函数代码，成员函数通过this指针能够得知要访问的对象的数据成员 1每个对象都拥有一个this指针，this指针记录对象的内存地址 1指向类自身数据的指针，简单来说就是指向当前类的当前实例对象 类的this指针特点 只能在成员函数中使用 this指针在成员函数开始前构造，在成员函数结束后清除 会因为不同的编译器存放在不同的位置 1234567891011121314151617181920212223242526linux@ubuntu:~/11_3$ cat test01.cpp#include&lt;iostream&gt;using namespace std;class Dog&#123; public: string name; void func();&#125;;int main()&#123; Dog dog; dog.func(); return 0; &#125;void Dog::func()&#123; this-&gt;name=&quot;雪碧&quot;; //this指针指向类的成员name，并赋值 cout&lt;&lt; &quot;狗狗的名字是：&quot;&lt;&lt;this-&gt;name&lt;&lt;endl;&#125;linux@ubuntu:~/11_3$ ./test01狗狗的名字是：雪碧 继承1面向对象中最重要的概念：继承 1继承允许我们依据另一个类来定义一个类 1当创建一个类时，不需要重新编写新的数据成员和数据函数，只需要指定新建的类继承一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 一个类可以派生自多个类，它可以从多个基类继承函数和数据。定义一个派生类，使用一个类派生列表来指定基类，类派生列表以一个或多个基类命名，如： 1class derived-class:access-specifier base-class 与类的访问修饰限定符一样，继承的方式有几种。其中，访问修饰符access-specifier是public、protected或private中的一个，base-class是之前定义的某个类的名称。如果未使用访问修饰符，则默认为private public(公有继承)：当一个类派生继承公有基类时，基类的公有成员也是派生类的公有成员。基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 protected(保护继承)：当一个类派生继承保护基类时，基类的公有和保护成员将成为派生类的保护成员 private(私有继承)：当一个派生继承私有基类时，基类的公有和保护成员将成为派生类的私有成员 12345678910111213141516171819202122232425262728293031323334353637383940414243linux@ubuntu:~/11_3$ vim test02.cpplinux@ubuntu:~/11_3$ g++ test02.cpp -o test02linux@ubuntu:~/11_3$ ./test02狗狗的名字是：雪碧狗狗的年龄是：18狗狗的颜色是：绿色狗狗的体重是：45linux@ubuntu:~/11_3$ cat test02.cpp #include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Animal //动物类，抽象出颜色和体重两种属性&#123; public: string color; //颜色成员变量 int weight; //体重成员变量&#125;;//让狗类继承这个动物类，并在狗类中写自己的属性class Dog:public Animal //Animal作为基类，Dog作为派生类。访问修饰符为public &#123; public: string name; int age; void run();&#125;;int main()&#123; Dog dog; dog.name=&quot;雪碧&quot;; dog.age=18; dog.color=&quot;绿色&quot;; dog.weight=45; cout&lt;&lt; &quot;狗狗的名字是：&quot;&lt;&lt;dog.name&lt;&lt;endl; cout&lt;&lt; &quot;狗狗的年龄是：&quot;&lt;&lt;dog.age&lt;&lt;endl; cout&lt;&lt; &quot;狗狗的颜色是：&quot;&lt;&lt;dog.color&lt;&lt;endl; cout&lt;&lt; &quot;狗狗的体重是：&quot;&lt;&lt;dog.weight&lt;&lt;endl; return 0;&#125; 重载函数重载和运算符重载 重载声明是指一个与之前已经在该作用域声明过的函数或方法具有相同名称的声明，当它们的参数列表和定义不同。 选择合适的重载函数或重载运算符的过程，称为重载决策 函数重载在同一作用域，可以声明几个功能类似的同名函数，但是这些同名函数形式参数（参数的个数、类型或顺序）必然不同。 12345678910111213141516171819202122232425262728293031linux@ubuntu:~/11_3$ vim test03.cpplinux@ubuntu:~/11_3$ g++ test03.cpp -o test03linux@ubuntu:~/11_3$ ./test03雪碧的体重是：20KG雪碧的体重是：22.5KGlinux@ubuntu:~/11_3$ cat test03.cpp #include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Dog&#123; public: string name; void getWeight(int weight)&#123; cout&lt;&lt;name&lt;&lt;&quot;的体重是：&quot;&lt;&lt;weight&lt;&lt;&quot;KG&quot;&lt;&lt;endl; &#125; void getWeight(double weight)&#123; cout&lt;&lt;name&lt;&lt;&quot;的体重是：&quot;&lt;&lt;weight&lt;&lt;&quot;KG&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; Dog dog; dog.name=&quot;雪碧&quot;; dog.getWeight(20); dog.getWeight(22.5); return 0;&#125; 运算符重载实质就是函数重载或函数多态。运算符重载是一种形式的C++多态。目的在于让人能够用同名的函数来完成不同的基本操作。 要重载运算符时，需要使用被称为运算符函数的特殊函数形式：operatorp(argument-list),operator后面的p为要重载的运算符符号，重载运算符格式： 1234&lt;返回类型说明符&gt;operator&lt;运算符符号&gt;（&lt;参数列表&gt;）&#123; &lt;函数&gt;&#125; 可重载的运算符列表： 双目算术运算符 关系运算符 逻辑运算符 单目运算符 +，-，*（指针），&amp;（取地址） 自增自减运算符 位运算符 赋值运算符 空间申请与释放 new,delete,new[],delete[] 其他运算符 （）（函数调用），-&gt;(成员访问)，，（逗号运算符），[]（下标） 不可重载的运算符列表 成员访问运算符 . 成员指针访问运算符 .*,-&gt; 域运算符 :: 长度运算符 sizeof() 条件运算符 ？： 预处理符号 # 123456789101112131415161718192021222324252627282930linux@ubuntu:~/11_3$ ./test04第三只小狗的体重为：30KGlinux@ubuntu:~/11_3$ cat test04.cpp #include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Dog&#123; public: int weight; Dog operator+(const Dog &amp;d)&#123; Dog dog; dog.weight=this-&gt;weight+d.weight; return dog; &#125;&#125;;int main()&#123; Dog dog1; Dog dog2; Dog dog3; dog1.weight=10; dog2.weight=20; dog3=dog1+dog2; cout&lt;&lt;&quot;第三只小狗的体重为：&quot;&lt;&lt;dog3.weight&lt;&lt;&quot;KG&quot;&lt;&lt;endl; return 0;&#125; 多态1c++多态意味着调用成员函数是，会根据调用函数的对象的类型来执行不同的函数 1234567891011形成多态必须具备的三个条件： 1、必须在继承关系 2、继承关系必须有同名虚函数 3、存在某类类型的指针或者引用，通过指针或引用调出虚函数虚函数： 是在某类中使用关键字virtual声明的函数，在派生类中重新定义其类中定义的虚函数时，会告诉编译器不要静态链接到该函数 virtual ReturnType FunctionName(Parameter)纯虚函数： 若在基类中定义虚函数，以便在派生类中重新定义该函数更好的适用于对象，但是在基类中有不能对虚函数给出有意义的实现，这个时候会用到纯虚函数。声明如下： virtual void function1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但是可以 12345678910111213141516171819202122232425262728293031323334353637383940414243444546linux@ubuntu:~/11_3$ ./test05Dog的run()方法Cat的run()方法linux@ubuntu:~/11_3$ cat test05.cpp#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Animal&#123; public: virtual void run()&#123; cout&lt;&lt;&quot;Animal的run()方法&quot;&lt;&lt;endl; &#125;&#125;;class Dog:public Animal&#123; public: void run() &#123; cout&lt;&lt;&quot;Dog的run()方法&quot;&lt;&lt;endl; &#125;&#125;;class Cat:public Animal&#123; public: void run()&#123; cout&lt;&lt;&quot;Cat的run()方法&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; Animal *animal; //声明一个Animal的指针对象，（没有实例化） Dog dog; //实例化dog对象 Cat cat; //实例化cat对象 animal=&amp;dog; //存储dog对象的地址 animal-&gt;run(); //调用run（）方法 animal=&amp;cat; //存储cat对象的地址 animal-&gt;run(); //调用run()方法 return 0;&#125; 数据封装封装是面向对象编程中把数据和操作的函数绑定在引起的的一个概念，这样能避免受到外界的干扰和误用，确保安全。数据封装申引出另一个重要的OPP概念，即数据隐藏。 数据封装是一种把数据和操作数据的函数绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，C++通过创建类来支持封装和数据隐藏（public,protected,private）。 数据抽象是指只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不是呈现细节。数据抽象是一种依赖于接口和实现分离的编程技术。 数据抽象的好处： 类的内部受到保护，不会因无意的用户级错误导致对象状态受损 类实现可能随时间的推移而变化，以便应对不断变化的需求，或者应对那些要求不改变用户级的错误信息。 在C++程序中，任何带有公有和私有成员的类都在C++程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。通常情况下，会设置成员状态为私有（private），除非我们需要将其暴露，这样才能保持良好的封装性。这通常应用于数据成员，但它同样适用于所有的成员，包括虚函数。 12345678910111213141516171819202122232425262728293031323334353637linux@ubuntu:~/11_3$ vim test06.cpplinux@ubuntu:~/11_3$ g++ test06.cpp -o test06linux@ubuntu:~/11_3$ ./test06雪碧一共获得了9份食物linux@ubuntu:~/11_3$ cat test06.cpp #include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Dog&#123; public: string name; Dog(int i=0)&#123; total=i; &#125; void addFood(int number)&#123; total=total+number; &#125; int getFood()&#123; return total; &#125; private: int total;&#125;;int main()&#123; Dog dog; dog.name=&quot;雪碧&quot;; dog.addFood(6); dog.addFood(3); cout&lt;&lt;dog.name&lt;&lt;&quot;一共获得了&quot;&lt;&lt;dog.getFood()&lt;&lt;&quot;份食物&quot;&lt;&lt;endl; return 0;&#125; 接口（抽象类）接口描述了类的行为和功能，而不需要完成类的特定实现。C++接口是使用抽象类来实现的，抽象类与数据抽象互补混淆，数据抽象是一个把实现细节于相关的数据分离开的概念。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用”&#x3D;0”来指定的 设计抽象类（ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能用于实例化对象，只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个ABC的子类需要被实例化，则必须实现每一个虚函数，这也意味着C++支持使用ABC声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。 1234567891011121314151617181920212223242526272829303132333435363738linux@ubuntu:~/11_3$ vim test07.cpplinux@ubuntu:~/11_3$ g++ test07.cpp -o test07linux@ubuntu:~/11_3$ ./test07Dog的run()方法Cat的run()方法linux@ubuntu:~/11_3$ cat test07.cpp #include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Animal&#123; public: virtual void run()=0; &#125;; //定义一个狗类并继承动物类class Dog:public Animal&#123; public: void run()&#123; cout&lt;&lt;&quot;Dog的run()方法&quot;&lt;&lt;endl; &#125; &#125;; //定义一个猫类并继承动物类class Cat:public Animal&#123; public: void run()&#123; cout&lt;&lt;&quot;Cat的run()方法&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; Dog dog; //实例化狗类 Cat cat; //实例化猫类 dog.run(); //dog调用run()方法 cat.run(); //cat调用run()方法 return 0;&#125;","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C++","slug":"C","permalink":"https://misakivv.github.io/tags/C/"}]},{"title":"嵌入式Day4","slug":"嵌入式Day4","date":"2023-11-16T15:07:09.000Z","updated":"2023-11-16T15:13:55.337Z","comments":true,"path":"2023/11/16/嵌入式Day4/","permalink":"https://misakivv.github.io/2023/11/16/%E5%B5%8C%E5%85%A5%E5%BC%8FDay4/","excerpt":"","text":"C++基础02构造函数与析构函数12345678910111213141516构造函数：在对象实例化时被系统调用，仅调用一次。特点：1. 构造函数必须与类名同名2. 可以重载3. 没有返回值类型，void也不行析构函数：在对象结束时系统自动执行。特点：1. 格式：~类名（）2. 在调用时释放内存资源3. ~类名（）不加参数4. 没有返回类型，void也不行 12345678910111213141516171819202122232425262728293031linux@ubuntu:~/11_2$ vim test04.cpplinux@ubuntu:~/11_2$ g++ test04.cpp -o test04linux@ubuntu:~/11_2$ ./test04构造函数执行！例子析构函数执行！linux@ubuntu:~/11_2$ cat test04.cpp#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Dog //定义一个狗类，并在里面写上构造函数和析构函数&#123; public: Dog(); ~Dog();&#125;;int main()&#123; Dog dog; //使用Dog实例化一个dog对象 cout&lt;&lt;&quot;例子&quot;&lt;&lt;endl; return 0;&#125;Dog::Dog() //类的函数可以在类里实现，也可以在类外实现，不过在类外实现需要使用&quot;::&quot;，这里是定义在类的外面&#123;cout&lt;&lt;&quot;构造函数执行！&quot;&lt;&lt;endl;&#125;Dog::~Dog() //类的析构函数定义在类的外面&#123; cout&lt;&lt;&quot;析构函数执行！&quot;&lt;&lt;endl;&#125;","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C++","slug":"C","permalink":"https://misakivv.github.io/tags/C/"}]},{"title":"嵌入式Day3","slug":"嵌入式Day3","date":"2023-11-16T14:49:59.000Z","updated":"2023-11-16T15:02:57.512Z","comments":true,"path":"2023/11/16/嵌入式Day3/","permalink":"https://misakivv.github.io/2023/11/16/%E5%B5%8C%E5%85%A5%E5%BC%8FDay3/","excerpt":"","text":"C++基础01123456C语言中： 输入设备--&gt;输入流--&gt;scanf--&gt;变量 变量--&gt;printf--&gt;输入流--&gt;输出设备C++语言中： 输入设备--&gt;输入流--&gt;cin--&gt;变量 变量--&gt;cout--&gt;输入流--&gt;输出设备 1234567891011121314cout语法形式： cout&lt;&lt;x&lt;&lt;endl;x可以是任意的数据类型，甚至是写成表达式，endl是换行符错误的写法： cout&lt;&lt;x,y&lt;&lt;endl; 在变量键不能使用&quot;,&quot;正确的写法： cout&lt;&lt;x&lt;&lt;y;cin语法形式： cin&gt;&gt;x;x可以是任意的数据类型 cin&gt;&gt;x&gt;&gt;y; 12345678910111213141516linux@ubuntu:~/11_1$ vim test01.cpplinux@ubuntu:~/11_1$ g++ test01.cpp -o test01linux@ubuntu:~/11_1$ ./test01 2010linux@ubuntu:~/11_1$ cat test01.cpp #include&lt;iostream&gt;using namespace std;int main()&#123; int x=20,y=10; cout&lt;&lt;x&lt;&lt;endl&lt;&lt;y&lt;&lt;endl; return 0;&#125;linux@ubuntu:~/11_1$ 123using是编译指令，声明当前命名空间的关键词。可以从字面上理解，翻译成使用。std::cinstd::cout 12345678910111213141516171819linux@ubuntu:~/11_1$ cat test02.cpp #include&lt;iostream&gt;using namespace std;namespace A&#123; int x=1; void fun()&#123; cout&lt;&lt;&quot;A namespace&quot;&lt;&lt;endl; &#125;&#125;using namespace A;//声明使用命名空间Aint main()&#123; fun(); //在前面声明了命名空间A后，才能直接使用fun()函数；否则要写成A::fun(); A::x=3; //将A命名空间下的x重新赋值为3 cout&lt;&lt;A::x&lt;&lt;endl; //打印A命名空间下x的值 A::fun(); //调用A命名空间下fun()。 return 0;&#125; 面向对象的三大特征：继承，多态，封装类和对象1类是C++的核心特征，通常被称为用户定义的类型。类用于指定对象的形式，包含数据表示法和用于处理数据的方法。类中的数据和方法被称为类的成员。 1234567891011121314151617181920212223242526272829303132linux@ubuntu:~/11_1$ cat test03.cpp#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Dog //定义一个Dog狗，起的类名要尽量贴近这个类，见名知意&#123; public : //访问限定符public(共有的) string name; //定义一个字符串变量，要使用头文件string int age; void run()&#123; //run()是为了打印狗的名字和年龄 cout&lt;&lt;&quot;狗狗的名字是： &quot;&lt;&lt;name&lt;&lt;&quot;,年龄为：&quot;&lt;&lt;age&lt;&lt;endl; &#125;&#125;;int main()&#123; Dog dog1; //从zhai中实例化一个对象dog1（随意起名） dog1.name=&quot;雪碧&quot;; //为dog1的成员变量赋值 dog1.age=3; dog1.run(); //打印dog1的相关变量信息 Dog *dog2=new Dog(); //从堆中实例化对象，使用关键字new的都是从堆中实例化对象 if(NULL==dog2)&#123; //从堆中实例化对象需要开辟空间，指针会指向那个内存 return 0; //如果new没有申请成功内存空间，程序会自动退出 &#125; dog2-&gt;name=&quot;柴柴&quot;; //为dog2的成员变量赋值 dog2-&gt;age=2; //为dog2的成员变量赋值 dog2-&gt;run(); //为dog2的成员变量赋值 delete dog2; //释放内存 dog2=NULL; //将dog2重新指向NULL return 0;&#125;","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C++","slug":"C","permalink":"https://misakivv.github.io/tags/C/"}]},{"title":"嵌入式Day2","slug":"嵌入式Day2","date":"2023-11-14T15:12:18.000Z","updated":"2023-11-14T15:27:33.584Z","comments":true,"path":"2023/11/14/嵌入式Day2/","permalink":"https://misakivv.github.io/2023/11/14/%E5%B5%8C%E5%85%A5%E5%BC%8FDay2/","excerpt":"","text":"Linux基础021.sudo1临时root用户权限 2.su1234567891011切换用户su 用户名linux@ubuntu:~$ su rootPassword: root@ubuntu:/home/linux# ^ ^ ^ 1 2 3 1.root用户 2.用户主目录的完整路径 3.#代表root用户权限 exit:退出用户 3.chmod1234567891011121314151617修改权限 三组用户：文件属主、文件属组、其他用户 r：可读 w：可写 x：可执行 -：没有对应的权限1.+、-、= +:添加权限 -:删除权限 =:设定权限 u(user):文件属主 g(group):文件属组 o(other):其他用户 a(all):所有用户 sudo chmod 用户+、-、=权限 文件名 sudo chmod 用户+、-、=权限 文件名 -R 2.八进制权限掩码 r、w、x = 1 =0 一组的权限 二进制 八进制 含义 — 000 0 都没有 –x 001 1 可执行 -w- 010 2 可写 -wx 011 3 可写可执行 r– 100 4 可读 r-x 101 5 可读可执行 rw- 110 6 可读可写 rwx 111 7 全都有 123456789sudo chmod 三组用户的八进制权限 文件名sudo chmod 三组用户的八进制权限 目录名 -R-rwxrwxr-x 1 linux linux 8928 Oct 30 14:17 test01111111101 7 7 5linux@ubuntu:~$ sudo chmod 777 test01-rwxrwxrwx- 1 linux linux 8928 Oct 30 14:17 test01111111111 7 7 7 4.apt-get1234sudo apt-get install 软件名:下载软件sudo apt-get remove 软件名:卸载软件sudo apt-get update:更新下载源sudo apt-get upgrade:更新所有的软件 5.tar123456789101112打包和解包1.打包-c:打包-v:显示打包的过程-f 包名:指定生成包的名字sudo tar -cvf 包名 源文件2.解包-x:解包-v:显示解包的过程-f:包名：指定要解包的包名-C:指定路径sudo tar -xvf 包名 6.vi&#x2F;vim123456789101112131415161718192021222324252627282930vim 文件名1.文件不存在，创建文件并进入编辑器2.文件存在，直接进入编辑器刚进去编辑器处于命令模式，输入i、a、o进入插入模式，按ESC键推出到命令模式，输入 :w 保存 :wq 保存并退出 :q 退出（没有做出如何修改） :q! 强制退出命令模式下的操作： yy:复制光标所在一行 p:粘贴至光标下一行 P:粘贴至光标上一行 nyy:n为数字，复制n行 dd:删除（剪切）光标所处一行 ndd:n为数字，删除或者剪切n行 u:撤销前一步操作 x:删除一个字符 gg:切换到首行 G:切换到尾行 nG:n为数字，切换到n行 $:切换到行尾 0:切换到行首 ZZ:保存并退出 ZQ:不保存退出多窗口编辑: 输入:冒号进入底行模式 在底行模式下 vs 文件名:垂直切分窗口 sp 文件名:竖直切分窗口 ctrl+ww:切换窗口 7.gcc编译器12345678910111213gcc 可选项 源文件编译流程:源文件.c--&gt;预处理--&gt;编译--&gt;汇编--&gt;链接--&gt;可执行文件gcc -E hello.c -o hello.igcc -S hello.i -o hello.sgcc -c hello.s -o hello.ogcc hello.o -o hello./hellogcc hello.c -o nihao./nihaogcc 源文件:默认生成a.out可执行文件，运行./执行文件名gcc 源文件 -o 自定义可执行文件名:生成自定义可执行文件，运行./可执行文件名 8.cat123456789101112将文件内容回显到终端上cat 文件名 -n:显示行号 linux@ubuntu:~/10_31$ cat -n hello.c 1 #include&lt;stdio.h&gt; 2 int main() 3 &#123; 4 printf(&quot;hello world\\n&quot;); 5 return 0; 6 7 &#125;tac 文件名:倒着回显 9.第一个C++程序123456789101112131415161718192021//文件名cpplinux@ubuntu:~/10_31$ cat hello.cpp#include&lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt;endl; return 0;&#125;//g++ 文件名: 编译c++文件 运行./可执行文件/*#include 包含头文件using namespace std;告诉编译器使用std命名空间。std是c++的标准命名空间。标准库写好了的int main():主函数，程序的开始return 0 :程序的结束cout:输出&lt;&lt;:重载运算符endl:换行 cout &lt;&lt; &quot;iKUN\\n&quot;&quot;hello world&quot; &lt;&lt; endl;*/","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Linux基础","slug":"Linux基础","permalink":"https://misakivv.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"嵌入式Day1","slug":"嵌入式Day1","date":"2023-11-14T15:01:50.000Z","updated":"2023-11-14T15:27:01.535Z","comments":true,"path":"2023/11/14/嵌入式Day1/","permalink":"https://misakivv.github.io/2023/11/14/%E5%B5%8C%E5%85%A5%E5%BC%8FDay1/","excerpt":"","text":"Linux基础011.打开终端12ctrl+Alt+t:打开终端ctrl+D:关闭终端 2.命令提示符 1234567891011121314linux@ubuntu:~$ ^ ^ ^^ 1 2 34 1.用户名 2.主机名 3.当前所处的工作路径，~：用户主目录 pwd:查看当前所处的完整路径 linux@ubuntu:~$ pwd /home/linux ^ ^ a b a.根目录 b.间隔符 4.$:普通用户权限 3.命令三要素12命令、可选项、参数三者之间空格隔开 4.ls1234567891011121314151617181920212223242526查看内容ls -a:查看所有文件，包括隐藏文件（以.开头的文件）.:当前目录 ..:上一级目录ls -l:查看内容的详细信息drwxr-xr-x 3 linux linux 4096 Oct 28 22:33 Desktop^ ^ ^ ^ ^ ^ ^ ^1 2 3 4 5 6 7 81.文件类型一切皆文件 -：普通文件 d：目录文件 b：块设备文件 c：字符设备文件 s：套接字文件 p：管道文件 l：链接文件2.文件权限 rwxr-xr-x 三组用户：文件属主、文件属组、其他用户 r：可读 w：可写 x：可执行 -：没有对应的权限3.文件链接数4.文件创建者5.同组用户6.文件大小7.文件最后一次修改时间8.文件名 5.man123man 1 命令:查看命令的用法man 2 系统函数:查看系统函数的用法man 3 库函数: 查看库函数的用法 6.cd123456789切换工作路径cd 路径cd ~:切换到用户主目录cd /:切换到根目录cd ..:切换到上一级目录cd ../..:切换到上两级目录cd -:切换到上一次使用过的目录相对路径:相对于当前所处的工作路径绝对路径:以根目录为起始的路径 7.mkdir1234创建目录mkdir 目录名mkdir -p 父目录/子目录:递归创建多级目录 8.touch12345创建文件touch 文件名1.文件不存在，创建文件2.文件存在，更改文件最后一次修改时间 9.cp12345678910111213141516171819202122拷贝文件或目录文件： cp 源文件 目标文件（拷贝到当前目录） cp 源目录 路径 linux@ubuntu:~/10_30$ touch hello.c linux@ubuntu:~/10_30$ ls -l total 4 drwxr-xr-x 3 linux linux 4096 Oct 29 19:38 a -rw-r--r-- 1 linux linux 0 Oct 29 19:42 hello.c linux@ubuntu:~/10_30$ cp hello.c test.c linux@ubuntu:~/10_30$ ls a hello.c test.c linux@ubuntu:~/10_30$ cp hello.c ./a linux@ubuntu:~/10_30$ ls ./a b hello.c linux@ubuntu:~/10_30$ cp hello.c ./a/test.c linux@ubuntu:~/10_30$ ls ./a b hello.c test.c目录： cp -r 源目录 目标目录：拷贝到当前目录 cp -r 源目录 路径：拷贝目录到指定路径 10.mv12345678移动或者重命名1.移动mv 源文件 路径：移动文件到指定路径mv 源目录 路径：移动目录到指定路径2.重命名mv 源文件 目标文件：重命名mv 源目录 目标目录：重命名 11.补充1234tab键：自动补全clear/ctrl l:清屏操作方向键上下键：上下查看使用过的指令history:查看历史指令 12.rm123456删除rm 文件名rm -r 目录名 -i:显示提示信息 -f:强制删除 13.练习12345671.在用户主目录创建以你的名字命名的目录2.在该目录下创建dir1、dir2、dir3目录3.重命名dir1目录为test014.复制dir3目录到test01目录中5.在dir2目录中创建test01.c、test02.c文件6.移动test02.c文件到dir3目录中7.删除test01目录","categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Linux基础","slug":"Linux基础","permalink":"https://misakivv.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-11-11T14:52:18.125Z","updated":"2023-11-11T14:52:18.125Z","comments":true,"path":"2023/11/11/hello-world/","permalink":"https://misakivv.github.io/2023/11/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"嵌入式实训","slug":"嵌入式实训","permalink":"https://misakivv.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Qt","slug":"Qt","permalink":"https://misakivv.github.io/tags/Qt/"},{"name":"简历格式","slug":"简历格式","permalink":"https://misakivv.github.io/tags/%E7%AE%80%E5%8E%86%E6%A0%BC%E5%BC%8F/"},{"name":"C++","slug":"C","permalink":"https://misakivv.github.io/tags/C/"},{"name":"Linux基础","slug":"Linux基础","permalink":"https://misakivv.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"}]}