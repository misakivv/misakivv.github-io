{"meta":{"title":"my blog","subtitle":"","description":"blog","author":"John Doe","url":"https://misakivv.github.io","root":"/"},"pages":[{"title":"about","date":"2023-11-12T02:01:42.000Z","updated":"2023-11-12T02:34:17.000Z","comments":true,"path":"about/index.html","permalink":"https://misakivv.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-12T02:02:00.000Z","updated":"2023-11-12T02:35:06.925Z","comments":true,"path":"tags/index.html","permalink":"https://misakivv.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-11-12T02:01:54.000Z","updated":"2023-11-12T02:34:33.621Z","comments":true,"path":"categories/index.html","permalink":"https://misakivv.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-11-12T02:02:15.000Z","updated":"2023-11-12T02:34:51.124Z","comments":true,"path":"friends/index.html","permalink":"https://misakivv.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"基于MP157开发板的智能家居系统","slug":"基于MP157开发板的智能家居系统 (2)","date":"2023-11-11T15:26:13.963Z","updated":"2023-11-11T15:28:42.950Z","comments":true,"path":"2023/11/11/基于MP157开发板的智能家居系统 (2)/","permalink":"https://misakivv.github.io/2023/11/11/%E5%9F%BA%E4%BA%8EMP157%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F%20(2)/","excerpt":"","text":"QT文件操作1.QFile读写文本提供读取写入文件的接口 文件名通常在构造函数中传递 123456QIDDevice::Readonly:以只读的方式打开文件，用于载入文件QIDDevice::Writeonly:以只写方式打开文件，用于保存文件QIDDevice::ReadWrite:以读写方式打开QIDDevice::Append:以添加模式打开，新写入文件的数据添加到文件末尾QIDDevice::Truncate:以裁取的方式打开文件，文件原有内容会被删除QIDDevice::Text:以文本打开文件 流程：文件–&gt;打开方式–&gt;关闭 1234567891011121314151617181920212223242526272829303132333435363738394041424344//main#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include&lt;QTextEdit&gt;#include&lt;QFile&gt;#include&lt;QVBoxLayout&gt;#include&lt;QHBoxLayout&gt;#include&lt;QPushButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;private: //用于读取文件后显示 QTextEdit *testEdit; QFile file; //QFile 类型对象 QHBoxLayout *hBoxLayout; //水平布局 QVBoxLayout *vBoxLayout; //垂直布局 QWidget *hwidget; //水平布局 widget QWidget *vwideget; //垂直布局 widget QPushButton *openPushButton; //打开文件按钮 QPushButton *closePushButton; //关闭文件按钮 private slots: bool openFile(); //打开文本文件 void closeFile(); //关闭文本文件&#125;;#endif // MAINWINDOW_H 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//mainwindow.h#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120); openPushButton-&gt;setText(&quot;open&quot;); closePushButton-&gt;setText(&quot;close&quot;); closePushButton-&gt;setEnabled(false); hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout); vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout); setCentralWidget(vwideget); connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this); file.setFileName(fileName); if(!file.exists()) return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false; textEdit-&gt;setPlainText(file.readAll()); openPushButton-&gt;setEnabled(false); closePushButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return; QByteArray strBytes = str.toUtf8(); file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); openPushButton-&gt;setEnabled(true); closePushButton-&gt;setEnabled(false);&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot; #include &lt;QFileDialog&gt; //标准通用对话框#include &lt;QDebug&gt; //信息输出头文件MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); //设置窗口的位置与大小//布局设置 textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120);//设置两个按钮的文本 openPushButton-&gt;setText(&quot;打开&quot;); closePushButton-&gt;setText(&quot;关闭&quot;);//设置关闭按钮为不可用属性，需要打开文件才设置为可用属性 closePushButton-&gt;setEnabled(false);//水平布局 hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout);//垂直布局 vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout);//居中 setCentralWidget(vwideget);//信号槽连接 connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this);//获取文件的路径 file.setFileName(fileName); //指向文件 if(!file.exists()) //判断文件是否存在 return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) //以读写的方式打开 return false; textEdit-&gt;setPlainText(file.readAll()); //读取文本到textEdit openPushButton-&gt;setEnabled(false); //设置打开按钮不可用，需要关闭再打开 closePushButton-&gt;setEnabled(true); //设置关闭按钮为可用属性 file.close(); //关闭文件 return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; //检测打开按钮是否可用，不可用时，说明已经打开了文件 QString str = textEdit-&gt;toPlainText(); //获取textEdit的文本内容 if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) //以只读的方式打开 return; QByteArray strBytes = str.toUtf8(); //转换为字节数组 file.write(strBytes,strBytes.length()); //写入文件 textEdit-&gt;clear(); //清空textEdit的显示内容 openPushButton-&gt;setEnabled(true); //重新设置打开何关闭按钮的属性 closePushButton-&gt;setEnabled(false);&#125;&#125; 2.QTextStream读写文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vwideget = new QWidget (); hwidget = new QWidget (); openPushButton = new QPushButton (); closePushButton = new QPushButton(); openPushButton-&gt;setMinimumHeight(50); openPushButton-&gt;setMaximumWidth(120); closePushButton-&gt;setMinimumHeight(50); closePushButton-&gt;setMaximumWidth(120); openPushButton-&gt;setText(&quot;open&quot;); closePushButton-&gt;setText(&quot;close&quot;); closePushButton-&gt;setEnabled(false); hBoxLayout-&gt;addWidget(openPushButton); hBoxLayout-&gt;addWidget(closePushButton); hwidget-&gt;setLayout(hBoxLayout); vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hwidget); vwideget-&gt;setLayout(vBoxLayout); setCentralWidget(vwideget); connect(openPushButton,SIGNAL(clicked()), this,SLOT(openFile())); connect(closePushButton,SIGNAL(clicked()), this,SLOT(openFile()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;bool MainWindow::openFile()&#123; QString fileName = QFileDialog::getOpenFileName(this); file.setFileName(fileName); if(!file.exists()) return false; if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) return false; QTextStream stream(&amp;file); textEdit-&gt;setPlainText(file.readAll()); openPushButton-&gt;setEnabled(false); closePushButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; if(!openPushButton-&gt;isEnabled())&#123; QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return; QTextStream stream(&amp;file); QString str_1 = textEdit-&gt;toPlainText(); stream &lt;&lt;str_1; //QByteArray strBytes = str.toUtf8(); //file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); openPushButton-&gt;setEnabled(true); closePushButton-&gt;setEnabled(false);&#125;&#125; QT多线程QThread类提供一种独立于平台的方法管理线程。 继承QThread的线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include&lt;QMainWindow&gt;#include&lt;QThread&gt;#include&lt;QDebug&gt;#include&lt;QPushButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class MainWindow; &#125;QT_END_NAMESPACEclass WorkerThread;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow();private: Ui::MainWindow *ui;private: WorkerThread *workThread; //声明对象 QPushButton *pushButton; //声明一个按钮，使用此按钮点击后开启线程 private slots: //槽函数，用于接受线程点击后开启线程 void headleResults(const QString &amp;result); void pushButtonClicked(); //点击按钮开启线程&#125;; //新建一个WorkThread类继承于QThreadclass WorkerThread : public QThread&#123; Q_OBJECT //用到信号槽即需要此宏定义 public: WorkerThread(QWidget *parent=nullptr)&#123; Q_UNUSED(parent); &#125; //重写run()方法 void run() override&#123; QString result=&quot;线程开启成功&quot;; sleep(2); //延迟2s emit resultReady(result); //发送结果准备好的信号 &#125; signals: //声明一个信号 void resultReady(const QString &amp;s);&#125;;#endif // MAINWINDOW_H 123456789101112131415161718192021222324252627282930313233343536373839//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); //设置位置与大小 pushButton=new QPushButton(this); //对象实例化 workerThread = new WorkerThread(this); //线程对象实例化//按钮设置大小与文本 pushButton-&gt;resize(100,40); pushButton-&gt;setText(&quot;圆神，启动&quot;);//信号槽连接 connect(workerThread,SIGNAL(resultReady(QString)),this,SLOT(handleResults(QString))); connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));&#125;MainWindow::~MainWindow()&#123; workerThread-&gt;quit(); //进程退出 if(workerThread-&gt;wait(2000))&#123; //阻塞等待2000ms检查一次进程是否已经退出 qDebug()&lt;&lt;&quot;Thread over!&quot;&lt;&lt;endl; &#125; delete ui;&#125;void MainWindow::handleResults(const QString &amp;result)&#123; qDebug()&lt;&lt;result&lt;&lt;endl; //打印线程发送过来的结果&#125;void MainWindow::pushButtonClicked()&#123; if(!workerThread-&gt;isRunning()) //检查线程是否再运行，如果没有则开始运行 workerThread-&gt;start();&#125; ![image-20231107154643093](D:\\github-blog\\source_posts\\基于MP157开发板的智能家居系统 (2)\\image-20231107154643093.png) ![image-20231107154609600](D:\\github-blog\\source_posts\\基于MP157开发板的智能家居系统 (2)\\image-20231107154609600.png)","categories":[],"tags":[]},{"title":"","slug":"基于MP157开发板的智能家居系统","date":"2023-11-11T15:22:16.317Z","updated":"2023-11-11T15:23:12.604Z","comments":true,"path":"2023/11/11/基于MP157开发板的智能家居系统/","permalink":"https://misakivv.github.io/2023/11/11/%E5%9F%BA%E4%BA%8EMP157%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1title: 基于MP157开发板的智能家居系统 组名 小组成员 linux、C++、QT QT写界面 MP157开发板 项目功能：环境监测，设备控制 123456789101112131415161718192021222324252627282930313233基于MP157开发板的智能家居系统结合Linux操作系统、C++编程和QT程序开发，可以采用以下总体设计：1. 硬件平台： - MP157开发板：作为嵌入式设备的核心，运行Linux操作系统和应用程序。 - 传感器模块：用于感知环境信息，如温度、湿度、光照等。 - 执行器模块：用于控制家居设备，如灯光、窗帘、空调等。 - 通信模块：用于与其他智能设备或云平台进行通信，如Wi-Fi模块、蓝牙模块等。2. 软件架构： - Linux操作系统：作为底层的操作系统，提供系统资源管理、进程调度和设备驱动等功能。 - C++编程：使用C++语言编写系统的核心逻辑和功能模块。 - QT程序开发：使用QT框架进行图形界面设计，方便用户交互和操作。 - 数据库：使用SQLite或其他轻量级数据库存储设备配置和状态信息。3. 功能模块： - 传感器数据采集：通过传感器模块获取环境信息，如温度、湿度等。 - 控制器驱动：通过执行器模块控制家居设备，如开关灯、调节温度等。 - 通信模块接口：与其他智能设备或云平台进行通信，实现远程控制和监控功能。 - 定时任务管理：设置定时任务，如定时开关灯、定时调整温度等。 - 用户界面：使用QT进行图形界面设计，提供友好的用户交互界面，实现设备配置和状态监控等功能。 - 数据存储和管理：使用数据库存储设备配置、历史数据和用户信息等。4. 工作流程： - 系统启动：开机自启动Linux操作系统和智能家居系统应用程序。 - 数据采集和处理：周期性地获取传感器数据，并根据预设逻辑进行处理和控制。 - 用户交互：通过QT界面，用户可以配置设备参数、查看设备状态，并进行远程控制。 - 通信功能：与其他智能设备或云平台进行通信，实现远程监控和控制。 - 数据存储和管理：将设备配置、历史数据和用户信息存储到数据库中，实现数据的持久化和管理。 - 异常处理：对于异常情况，如传感器故障或通信异常，系统应提供相应的处理机制，如报警或错误提示。以上是基于MP157开发板的智能家居系统的总体设计。具体实现时，可以根据需求进行适当调整和扩展。 &#x2F;********************************************************&#x2F; 123456789101112131415这些控制模块的函数是为了实现智能家居系统中各种设备的控制功能。每个函数对应一个具体的设备操作，如打开或关闭某个LED灯、风扇或蜂鸣器等。下面对这些函数进行逐一解释：1. `led1_on_btnSlot()`和`led1_off_btnSlot()`：这两个函数用于控制LED1灯的开关状态，`led1_on_btnSlot()`用于打开LED1灯，`led1_off_btnSlot()`用于关闭LED1灯。2. `led2_on_btnSlot()`和`led2_off_btnSlot()`：这两个函数用于控制LED2灯的开关状态，`led2_on_btnSlot()`用于打开LED2灯，`led2_off_btnSlot()`用于关闭LED2灯。3. `led3_on_btnSlot()`和`led3_off_btnSlot()`：这两个函数用于控制LED3灯的开关状态，`led3_on_btnSlot()`用于打开LED3灯，`led3_off_btnSlot()`用于关闭LED3灯。4. `fan_on_btnSlot()`和`fan_off_btnSlot()`：这两个函数用于控制风扇的开关状态，`fan_on_btnSlot()`用于打开风扇，`fan_off_btnSlot()`用于关闭风扇。5. `fan_2_btnSlot()`和`fan_3_btnSlot()`：这两个函数用于控制风扇的速度，`fan_2_btnSlot()`用于设置风扇速度为2档，`fan_3_btnSlot()`用于设置风扇速度为3档。6. `beep_on_btnSlot()`和`beep_off_btnSlot()`：这两个函数用于控制蜂鸣器的开关状态，`beep_on_btnSlot()`用于打开蜂鸣器，`beep_off_btnSlot()`用于关闭蜂鸣器。通过这些控制模块的函数，用户可以通过相应的按钮或操作界面来控制各种设备的开关、速度等状态，实现智能家居的远程控制和自动化控制功能。这些函数的实现可以根据具体的硬件和控制逻辑进行调整和扩展。 123湿度（humidity）温度（temperature）光照强度（illumination） &#x2F;########&#x2F; 12345678910111213141516171819202122232425connect(ui-&gt;pushButton_led1_on,SIGNAL(clicked()),this,SLOT(led1_on_btnSlot()));：将pushButton_led1_on按钮的clicked()信号连接到当前类的led1_on_btnSlot()槽函数。connect(ui-&gt;pushButton_led1_off,SIGNAL(clicked()),this,SLOT(led1_off_btnSlot()));：将pushButton_led1_off按钮的clicked()信号连接到当前类的led1_off_btnSlot()槽函数。connect(ui-&gt;pushButton_led2_on,SIGNAL(clicked()),this,SLOT(led2_on_btnSlot()));：将pushButton_led2_on按钮的clicked()信号连接到当前类的led2_on_btnSlot()槽函数。connect(ui-&gt;pushButton_led2_off,SIGNAL(clicked()),this,SLOT(led2_off_btnSlot()));：将pushButton_led2_off按钮的clicked()信号连接到当前类的led2_off_btnSlot()槽函数。connect(ui-&gt;pushButton_led3_on,SIGNAL(clicked()),this,SLOT(led3_on_btnSlot()));：将pushButton_led3_on按钮的clicked()信号连接到当前类的led3_on_btnSlot()槽函数。connect(ui-&gt;pushButton_led3_off,SIGNAL(clicked()),this,SLOT(led3_off_btnSlot()));：将pushButton_led3_off按钮的clicked()信号连接到当前类的led3_off_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_on,SIGNAL(clicked()),this,SLOT(fan_on_btnSlot()));：将pushButton_fan_on按钮的clicked()信号连接到当前类的fan_on_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_off,SIGNAL(clicked()),this,SLOT(fan_off_btnSlot()));：将pushButton_fan_off按钮的clicked()信号连接到当前类的fan_off_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_2,SIGNAL(clicked()),this,SLOT(fan_2_btnSlot()));：将pushButton_fan_2按钮的clicked()信号连接到当前类的fan_2_btnSlot()槽函数。connect(ui-&gt;pushButton_fan_3,SIGNAL(clicked()),this,SLOT(fan_3_btnSlot()));：将pushButton_fan_3按钮的clicked()信号连接到当前类的fan_3_btnSlot()槽函数。connect(ui-&gt;pushButton_beep_on,SIGNAL(clicked()),this,SLOT(beep_on_btnSlot()));：将pushButton_beep_on按钮的clicked()信号连接到当前类的beep_on_btnSlot()槽函数。connect(ui-&gt;pushButton_beep_off,SIGNAL(clicked()),this,SLOT(beep_off_btnSlot()));：将pushButton_beep_off按钮的clicked()信号连接到当前类的beep_off_btnSlot()槽函数。总体来说，这些connect语句建立了按钮点击信号与相应槽函数的关联，使得当用户点击某个按钮时，与之相关的槽函数将被调用，执行特定的操作。这种机制使得界面和功能之间得以有效的交互。 &#x2F;######&#x2F; 12345678910111213led1_on_btnSlot(): 当led1开关按钮被按下时，设置led1开状态的按钮样式并根据板子类型设置对应的LED1亮度。led1_off_btnSlot(): 当led1关闭按钮被按下时，设置led1关状态的按钮样式并根据板子类型设置对应的LED1亮度。led2_on_btnSlot(): 当led2开关按钮被按下时，设置led2开状态的按钮样式并根据板子类型设置对应的LED2亮度。led2_off_btnSlot(): 当led2关闭按钮被按下时，设置led2关状态的按钮样式并根据板子类型设置对应的LED2亮度。led3_on_btnSlot(): 当led3开关按钮被按下时，设置led3开状态的按钮样式并根据板子类型设置对应的LED3亮度。led3_off_btnSlot(): 当led3关闭按钮被按下时，设置led3关状态的按钮样式并根据板子类型设置对应的LED3亮度。fan_on_btnSlot(): 当风扇开关按钮被按下时，设置风扇开状态的按钮样式并根据板子类型设置对应的风扇转速。fan_off_btnSlot(): 当风扇关闭按钮被按下时，设置风扇关状态的按钮样式并根据板子类型设置对应的风扇转速。fan_2_btnSlot(): 当风扇2档按钮被按下时，设置风扇2档状态的按钮样式并根据板子类型设置对应的风扇转速。fan_3_btnSlot(): 当风扇3档按钮被按下时，设置风扇3档状态的按钮样式并根据板子类型设置对应的风扇转速。beep_on_btnSlot(): 当蜂鸣器开关按钮被按下时，设置蜂鸣器开状态的按钮样式并执行响铃操作。beep_off_btnSlot(): 当蜂鸣器关闭按钮被按下时，设置蜂鸣器关状态的按钮样式并停止响铃操作。这些槽函数通过修改界面按钮的样式并调用特定的系统命令或函数来控制硬件设备（如LED、风扇、蜂鸣器）的状态，实现了用户界面与硬件设备的交互控制。 123456789 再添加库文件引用：win32:CONFIG(release, debug|release): LIBS += -L$$PWD/lib/ -lQt5Mqttelse:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/lib/ -lQt5Mqttd添加 include 文件的引用：INCLUDEPATH += $$PWD/includeDEPENDPATH += $$PWD/include 1234567891011在本次MP157开发板的智能家居系统实训中，我担任小组长一职，全程负责协调小组成员完成任务，经历了一系列的规划、开发、调试和测试阶段。通过这次实训，我收获颇丰，不仅深化了对嵌入式系统和物联网技术的理解，还提升了团队协作和项目管理的能力。首先，我学到了如何有效地规划和组织项目。在项目开始之前，我与小组成员共同制定了详细的计划和任务分配，明确了每个人的责任和目标。这有助于确保项目有序进行，每个任务都能按时完成。同时，我学到了灵活应对计划变动的能力，随时调整团队的工作重心，以应对新的挑战和需求。其次，通过实际操作，我加深了对MP157开发板的理解和应用。在项目中，我们需要与传感器、执行器、网络模块等硬件设备进行交互，通过C++/Qt编程实现智能家居系统的各项功能，如灯光控制、温度监测、远程控制等。这让我更加熟悉嵌入式开发的流程，提高了代码调试和优化的能力。协调小组成员也是我在这次实训中的一项重要经验。通过定期的小组会议，我能够了解每个成员的工作进展、遇到的问题，并及时提供帮助和支持。在面对团队内部的协作问题时，我学到了沟通和解决冲突的技巧，使整个团队能够更加紧密地合作。在这个过程中，我还学到了如何有效地进行团队管理。合理分配任务，鼓励团队成员分享经验和思路，及时解决困难，都是成功管理一个小组的关键。通过这次实训，我更加明确了领导者在项目中的重要性，也懂得了在团队中发挥每个成员的优势，使整个团队更具创造力和执行力。总的来说，这次MP157开发板的智能家居系统实训为我提供了一个全面锻炼技术和管理能力的机会。我不仅掌握了更多的技术知识，还提高了团队协作和项目管理的实际能力。这将对我的未来职业发展产生积极的影响，使我更好地适应和应对复杂的工程项目。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-11-11T14:52:18.125Z","updated":"2023-11-11T14:52:18.125Z","comments":true,"path":"2023/11/11/hello-world/","permalink":"https://misakivv.github.io/2023/11/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}