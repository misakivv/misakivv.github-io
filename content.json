{"meta":{"title":"my blog","subtitle":"","description":"blog","author":"John Doe","url":"https://misakivv.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2023-11-14T14:50:57.000Z","updated":"2023-11-14T14:52:06.400Z","comments":false,"path":"/404.html","permalink":"https://misakivv.github.io/404.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-11-14T14:44:59.448Z","updated":"2023-11-14T14:44:59.448Z","comments":true,"path":"categories/index.html","permalink":"https://misakivv.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-11-14T14:44:37.336Z","updated":"2023-11-14T14:44:37.336Z","comments":true,"path":"tags/index.html","permalink":"https://misakivv.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-11-12T02:02:15.000Z","updated":"2023-11-12T02:34:51.124Z","comments":true,"path":"friends/index.html","permalink":"https://misakivv.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-11-14T14:45:26.208Z","updated":"2023-11-14T14:45:26.208Z","comments":true,"path":"about/index.html","permalink":"https://misakivv.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"嵌入式Day1","slug":"嵌入式Day1","date":"2023-11-14T15:01:50.000Z","updated":"2023-11-14T15:05:34.120Z","comments":true,"path":"2023/11/14/嵌入式Day1/","permalink":"https://misakivv.github.io/2023/11/14/%E5%B5%8C%E5%85%A5%E5%BC%8FDay1/","excerpt":"","text":"Linux基础011.打开终端12ctrl+Alt+t:打开终端ctrl+D:关闭终端 2.命令提示符 1234567891011121314linux@ubuntu:~$ ^ ^ ^^ 1 2 34 1.用户名 2.主机名 3.当前所处的工作路径，~：用户主目录 pwd:查看当前所处的完整路径 linux@ubuntu:~$ pwd /home/linux ^ ^ a b a.根目录 b.间隔符 4.$:普通用户权限 3.命令三要素12命令、可选项、参数三者之间空格隔开 4.ls1234567891011121314151617181920212223242526查看内容ls -a:查看所有文件，包括隐藏文件（以.开头的文件）.:当前目录 ..:上一级目录ls -l:查看内容的详细信息drwxr-xr-x 3 linux linux 4096 Oct 28 22:33 Desktop^ ^ ^ ^ ^ ^ ^ ^1 2 3 4 5 6 7 81.文件类型一切皆文件 -：普通文件 d：目录文件 b：块设备文件 c：字符设备文件 s：套接字文件 p：管道文件 l：链接文件2.文件权限 rwxr-xr-x 三组用户：文件属主、文件属组、其他用户 r：可读 w：可写 x：可执行 -：没有对应的权限3.文件链接数4.文件创建者5.同组用户6.文件大小7.文件最后一次修改时间8.文件名 5.man123man 1 命令:查看命令的用法man 2 系统函数:查看系统函数的用法man 3 库函数: 查看库函数的用法 6.cd123456789切换工作路径cd 路径cd ~:切换到用户主目录cd /:切换到根目录cd ..:切换到上一级目录cd ../..:切换到上两级目录cd -:切换到上一次使用过的目录相对路径:相对于当前所处的工作路径绝对路径:以根目录为起始的路径 7.mkdir1234创建目录mkdir 目录名mkdir -p 父目录/子目录:递归创建多级目录 8.touch12345创建文件touch 文件名1.文件不存在，创建文件2.文件存在，更改文件最后一次修改时间 9.cp12345678910111213141516171819202122拷贝文件或目录文件： cp 源文件 目标文件（拷贝到当前目录） cp 源目录 路径 linux@ubuntu:~/10_30$ touch hello.c linux@ubuntu:~/10_30$ ls -l total 4 drwxr-xr-x 3 linux linux 4096 Oct 29 19:38 a -rw-r--r-- 1 linux linux 0 Oct 29 19:42 hello.c linux@ubuntu:~/10_30$ cp hello.c test.c linux@ubuntu:~/10_30$ ls a hello.c test.c linux@ubuntu:~/10_30$ cp hello.c ./a linux@ubuntu:~/10_30$ ls ./a b hello.c linux@ubuntu:~/10_30$ cp hello.c ./a/test.c linux@ubuntu:~/10_30$ ls ./a b hello.c test.c目录： cp -r 源目录 目标目录：拷贝到当前目录 cp -r 源目录 路径：拷贝目录到指定路径 10.mv12345678移动或者重命名1.移动mv 源文件 路径：移动文件到指定路径mv 源目录 路径：移动目录到指定路径2.重命名mv 源文件 目标文件：重命名mv 源目录 目标目录：重命名 11.补充1234tab键：自动补全clear/ctrl l:清屏操作方向键上下键：上下查看使用过的指令history:查看历史指令 12.rm123456删除rm 文件名rm -r 目录名 -i:显示提示信息 -f:强制删除 13.练习12345671.在用户主目录创建以你的名字命名的目录2.在该目录下创建dir1、dir2、dir3目录3.重命名dir1目录为test014.复制dir3目录到test01目录中5.在dir2目录中创建test01.c、test02.c文件6.移动test02.c文件到dir3目录中7.删除test01目录","categories":[{"name":"实训","slug":"实训","permalink":"https://misakivv.github.io/categories/%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式 Linux","slug":"嵌入式-Linux","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"}]},{"title":"QT多线程02","slug":"QT多线程02","date":"2023-11-12T06:40:02.000Z","updated":"2023-11-12T07:36:59.268Z","comments":true,"path":"2023/11/12/QT多线程02/","permalink":"https://misakivv.github.io/2023/11/12/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B02/","excerpt":"","text":"QT多线程02继承QObject的线程 继承QObject类更加灵活。它通过 QObject::moveToThread()方法将它移到一个 QThread 线程里 执行。那么可以通过主线程发送信号去调用 QThread 线程的方法如上图的 fun4()，fun5()等等。这些方 法都是在 QThread 线程里执行的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;#include &lt;QMutexLocker&gt;#include &lt;QMutex&gt;/* 工人类 */class Worker;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 开始线程按钮 */QPushButton *pushButton1;QPushButton *pushButton2;/* 全局线程 */QThread workerThread;/* 工人类 */Worker *worker;private slots:/* 按钮 1 点击开启线程 */void pushButton1Clicked();/* 按钮 2 点击打断线程 */void pushButton2Clicked();/* 用于接收工人是否在工作的信号 */void handleResults(const QString &amp;);signals:/* 工人开始工作（做些耗时的操作 ） */void startWork(const QString &amp;);&#125;;/* Worker 类，这个类声明了 doWork1 函数，将整个 Worker 类移至线程 workerThread*/class Worker : public QObject&#123;Q_OBJECTprivate:/* 互斥锁 */QMutex lock;/* 标志位 */bool isCanRun;public slots:/* 耗时的工作都放在槽函数下，工人可以有多份不同的工作，但是每次只能去做一份 */void doWork1(const QString &amp;parameter) &#123;/* 标志位为真 */isCanRun = true;/* 死循环 */while (1) &#123;/* 此&#123;&#125;作用是 QMutexLocker 与 lock 的作用范围，获取锁后，* 运行完成后即解锁 */&#123;QMutexLocker locker(&amp;lock);/* 如果标志位不为真 */if (!isCanRun) &#123;/* 跳出循环 */break;&#125;&#125;/* 使用 QThread 里的延时函数，当作一个普通延时 */QThread::sleep(2);emit resultReady(parameter + &quot;doWork1 函数&quot;);&#125;/* doWork1 运行完成，发送信号 */emit resultReady(&quot;打断 doWork1 函数&quot;);&#125;// void doWork2();...public:/* 打断线程（注意此方法不能放在槽函数下） */void stopWork() &#123;qDebug()&lt;&lt;&quot;打断线程&quot;&lt;&lt;endl;/* 获取锁后，运行完成后即解锁 */QMutexLocker locker(&amp;lock);isCanRun = false;&#125;signals:/* 工人工作函数状态的信号 */void resultReady(const QString &amp;result);&#125;;#endif // MAINWINDOW_H 第 51105 行，声明一个 Worker 的类继承 QObject 类，这里是参考 Qt 的 QThread 类的帮助文档的 写法。 第 6288 行，我们把耗时的工作都放于槽函数下。工人可以有不同的工作，但是每次只能去做一份。 这里不同于继承 QThread 类的线程 run()，继承 QThread 的类只有 run()在新线程里。而继承 QObject 的类，使用 moveToThread()可以把整个继承的 QObject 类移至线程里执行，所以可以有 doWork1(),doWork2…等等耗时的操作，但是这些耗时的操作都应该作为槽函数，由主线程去调用。 第 67~80 行，进入循环后使用互拆锁判断 isCanRun 变量的状态，为假即跳出 while 循环，直到 doWork1 结束。注意，虽然 doWork1 结束了，但是线程并没有退出（结束）。因为我们把这个类移到 线程里了，直到这个类被销毁。或者使用 quit()和 exit()退出线程才真正的结束！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475mainwindow.cpp#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置显示位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);pushButton1 = new QPushButton(this);pushButton2 = new QPushButton(this);/* 设置按钮的位置大小 */pushButton1-&gt;setGeometry(300, 200, 80, 40);pushButton2-&gt;setGeometry(400, 200, 80, 40);/* 设置两个按钮的文本 */pushButton1-&gt;setText(&quot;开启线程&quot;);pushButton2-&gt;setText(&quot;打断线程&quot;);worker = new Worker;/* 将 worker 类移至线程 workerThread */worker-&gt;moveToThread(&amp;workerThread);/* 信号槽连接 *//* 线程完成销毁对象 */connect(&amp;workerThread, SIGNAL(finished()),worker, SLOT(deleteLater()));connect(&amp;workerThread, SIGNAL(finished()),&amp;workerThread, SLOT(deleteLater()));/* 发送开始工作的信号，开始工作 */connect(this, SIGNAL(startWork(QString)),worker, SLOT(doWork1(QString)));/* 接收到 worker 发送过来的信号 */connect(worker, SIGNAL(resultReady(QString)),this, SLOT(handleResults(QString)));/* 点击按钮开始线程 */connect(pushButton1, SIGNAL(clicked()),this, SLOT(pushButton1Clicked()));/* 点击按钮打断线程 */connect(pushButton2, SIGNAL(clicked()),this, SLOT(pushButton2Clicked()));&#125;MainWindow::~MainWindow()&#123;/* 打断线程再退出 */worker-&gt;stopWork();workerThread.quit();/* 阻塞线程 2000ms，判断线程是否结束 */if (workerThread.wait(2000)) &#123;qDebug()&lt;&lt;&quot;线程结束&quot;&lt;&lt;endl;&#125;&#125;void MainWindow::pushButton1Clicked()&#123;/* 字符串常量 */const QString str = &quot;正在运行&quot;;/* 判断线程是否在运行 */if(!workerThread.isRunning()) &#123;/* 开启线程 */workerThread.start();&#125;/* 发送正在运行的信号，线程收到信号后执行后返回线程耗时函数 + 此字符串 */emit this-&gt;startWork(str);&#125;void MainWindow::pushButton2Clicked()&#123;/* 如果线程在运行 */if(workerThread.isRunning()) &#123;/* 停止耗时工作，跳出耗时工作的循环 */worker-&gt;stopWork();&#125;&#125;void MainWindow::handleResults(const QString &amp; results)&#123;/* 打印线程的状态 */qDebug()&lt;&lt;&quot;线程的状态：&quot;&lt;&lt;results&lt;&lt;endl;&#125; 第 20 行，工人类实例化。继承 QObject 的多线程类不能指定父对象。 第 24 行，工人类实例化后，工人类将自己移至 workerThread 线程里执行。 第 29~32 行，线程结束后，我们需要使用 deleteLater 来销毁 worker 对象和 workerThread对象分配 的内存。deleteLater 会确认消息循环中没有这两个线程的对象后销毁。 网络编程1234567Qt网络模块为我们提供了编写 TCP / IP 客户端和服务器的类。它提供了较低级别的类，例如代表低级网络概念的 QTcpSocket，QTcpServer 和 QUdpSocket，以及诸如 QNetworkRequest，QNetworkReply和 QNetworkAccessManager 之类的高级类来执行使用通用协议的网络操作。 它还提供了诸如QNetworkConfiguration，QNetworkConfigurationManager和QNetworkSession等类，实现承载管理。想要在程序中使用 Qt 网络模块，我们需要在 pro 项目配置文件里增加下面的一条语句。QT += network 获取本机的网络信息为什么先写获取本机网络信息的内容呢？在建立网络通信之前我们至少得获取对方的 IP地址。在网络应 用中，经常需要用到本机的主机名、IP 地址、MAC 地址等网络信息，通常通在 Windows 通过调出命 令行 cmd 窗口输入 ipconfig 或者在 Linux 系统中使用 ifconfig 命令就可以查看相关信息了，在这里我 们利用 Qt 做出一个可以查询的界面和功能出来。 Qt 提供了 QHostInfo 和 QNetworkInterface 类可以用于此类信息查询。更多关于 QHostInfo和 QNetworkInterface 的相关函数可以在 Qt 的帮助文档中找到。 123456789101112131415161718192021222324252627//networkhostinfo.proQT += core gui networkgreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsCONFIG += c++11# The following define makes your compiler emit warnings if you use# any Qt feature that has been marked deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES += QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain#version of Qt.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the#APIs deprecated before Qt 6.0.0SOURCES += \\main.cpp \\mainwindow.cppHEADERS += \\mainwindow.h# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target 12345678910111213141516171819202122232425262728293031323334353637383940414243//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QPushButton&gt;#include &lt;QTextBrowser&gt;#include &lt;QVBoxLayout&gt;#include &lt;QHBoxLayout&gt;#include &lt;QTimer&gt;class MainWindow : public QMainWindow&#123;Q_OBJECTpublic:MainWindow(QWidget *parent = nullptr);~MainWindow();private:/* 点击获取和清空文本按钮 */QPushButton *pushButton[2];/* 文本浏览框用于显示本机的信息 */QTextBrowser *textBrowser;/* 水平 Widget 容器和垂直 Widget 容器*/QWidget *hWidget;QWidget *vWidget;/* 水平布局和垂直布局 */QHBoxLayout *hBoxLayout;QVBoxLayout *vBoxLayout;/* 定时器 */QTimer *timer;/* 获取本机的网络的信息，返回类型是 QString */QString getHostInfo();private slots:/* 定时器槽函数，点击按钮后定时触发 */void timerTimeOut();/* 显示本机信息 */void showHostInfo();/* 启动定时器 */void timerStart();/* 清空 textBrowser 的信息 */void clearHostInfo();&#125;;#endif // MAINWINDOW_H 头文件里主要是声明两个按钮和一个文本浏览框。另外还有一个定时器，声明一些槽函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &lt;QtNetwork/QNetworkInterface&gt;#include &lt;QtNetwork/QHostInfo&gt;#include &lt;QThread&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent): QMainWindow(parent)&#123;/* 设置位置与大小 */this-&gt;setGeometry(0, 0, 800, 480);/* 点击获取本地信息按钮和清空文本按钮 */pushButton[0] = new QPushButton();pushButton[1] = new QPushButton();pushButton[0]-&gt;setText(&quot;获取本机信息&quot;);pushButton[1]-&gt;setText(&quot;清空文本信息&quot;);/* 按钮的大小根据文本自适应，* 注意 setSizePolicy 需要在布局中使用 */pushButton[0]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);pushButton[1]-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);/* 水平 Widget 和垂直 Widget 用于添加布局 */hWidget = new QWidget();vWidget = new QWidget();/* 水平布局和垂直布局 */hBoxLayout = new QHBoxLayout();vBoxLayout = new QVBoxLayout();/* 文本浏览框 */textBrowser = new QTextBrowser();/* 添加到水平布局 */hBoxLayout-&gt;addWidget(pushButton[0]);hBoxLayout-&gt;addWidget(pushButton[1]);/* 将水平布局设置为 hWidget 的布局 */hWidget-&gt;setLayout(hBoxLayout);/* 将文本浏览框和 hWidget 添加到垂直布局 */vBoxLayout-&gt;addWidget(textBrowser);vBoxLayout-&gt;addWidget(hWidget);/* 将垂直布局设置为 vWidget 的布局 */vWidget-&gt;setLayout(vBoxLayout);/* 设置 vWidget 为中心部件 */setCentralWidget(vWidget);/* 定时器初始化 */timer = new QTimer();/* 信号槽连接 */connect(pushButton[0], SIGNAL(clicked()),this, SLOT(timerStart()));connect(pushButton[1], SIGNAL(clicked()),this, SLOT(clearHostInfo()));connect(timer, SIGNAL(timeout()),this, SLOT(timerTimeOut()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::timerStart()&#123;/* 清空文本 */textBrowser-&gt;clear();/* 定时 1s */timer-&gt;start(1000);&#125;void MainWindow::timerTimeOut()&#123;/* 显示本机信息 */showHostInfo();/* 停止定时器 */timer-&gt;stop();&#125;QString MainWindow::getHostInfo()&#123;/* 通过 QHostInfo 的 localHostName 函数获取主机名称 */QString str = &quot;主机名称：&quot; + QHostInfo::localHostName() + &quot;\\n&quot;;/* 获取所有的网络接口，* QNetworkInterface 类提供主机的 IP 地址和网络接口的列表 */QList&lt;QNetworkInterface&gt; list = QNetworkInterface::allInterfaces();/* 遍历 list */foreach (QNetworkInterface interface, list) &#123;str+= &quot;网卡设备:&quot; + interface.name() + &quot;\\n&quot;;str+= &quot;MAC 地址:&quot; + interface.hardwareAddress() + &quot;\\n&quot;;/* QNetworkAddressEntry 类存储 IP 地址子网掩码和广播地址 */QList&lt;QNetworkAddressEntry&gt; entryList = interface.addressEntries();/* 遍历 entryList */foreach (QNetworkAddressEntry entry, entryList) &#123;/* 过滤 IPv6 地址，只留下 IPv4 */if (entry.ip().protocol() == QAbstractSocket::IPv4Protocol) &#123;str+= &quot;IP 地址:&quot; + entry.ip().toString() + &quot;\\n&quot;;str+= &quot;子网掩码:&quot; + entry.netmask().toString() + &quot;\\n&quot;;str+= &quot;广播地址:&quot; + entry.broadcast().toString() + &quot;\\n\\n&quot;;&#125;&#125;&#125;/* 返回网络信息 */return str;&#125;void MainWindow::showHostInfo()&#123;/* 获取本机信息后显示到 textBrowser */textBrowser-&gt;insertPlainText(getHostInfo());&#125;void MainWindow::clearHostInfo()&#123;/* 判断 textBrowser 是否为空，如果不为空则清空文本 */if (!textBrowser-&gt;toPlainText().isEmpty())/* 清空文本 */textBrowser-&gt;clear();&#125; 12345第 90~123 行，是本例最重要的代码。第 93 行，通过 QHostInfo 的 localHostName 函数获取主机名称。第 97~98 行，通过 QNetworkInterface::allInterfaces()获取网络接口列表 list 类存储 IP 地址子网掩码和广播地址。如果我们用 qDebug()函数打印出 list，可以发现获取了所有的网络信息。而我们要提取网络里面的网络信息使用 QNetworkAddressEntry。第 106~107 行，使用 QNetworkAddressEntry 从 interface 接口里使用函数addressEntries()，获取所有的条目。就可以使用 QNetworkAddressEntry 的对象 entry 获取 IP地址子网掩码和广播地址。第 110~118 行，因为获取的 entries 在一个 QNetworkInterface 下可能有两个 IP，分别是 ipv4和 ipv6。这里使用 ip().protocol()来判断协议的类型，只留下 ipv4 类型的信息。筛选信息在我们写程序常常需要的。 套接字socket编程 socket概述 接字，用于描述IP地址和端口号 socket时链接运行在网络上的两个程序间的双向通信的端点。 通讯两端都有socket，数据在两个socket之间通过IO进行传输。 套接字是一种特殊的I&#x2F;O接口，在代码内体现为特殊的文件描述符，socket是一种常见的进程间通信。 套接字主要有三种类型： 12345671、流式套接字（SOCK_STREAM）流式套接字提供可靠的，面向连接的通信流，保证数据传输的可靠性和有序性。TCP通信使用该套接字。2、数据报套接字（SOCK_DGRAM）提供不可靠、无连接的通信流，不保证可靠传输、无序。UDP通信使用该套接字。3、原始套接字（SOCK_RAW）允许对底层协议进行访问，功能强大但不方便。 TCP连接的建立：三次握手 TCP连接的释放：四次挥手 socket通信 服务器端将一个套接字绑定到一个特定的端口，并通过这个套接字等待和监听客户的连接请求。 客户端根据服务器所在的主机和端口号发送连接请求。 如果一切正常，服务器接受连接请求，并且获得一个新的绑定到不同端口地址的套接字。 服务器端和客户端通过读写套接字进行通讯。 流程图 服务器端如果需要使用TCP协议创建一个服务器，需要以下步骤： 创建套接字 绑定套接字 设置监听模式 接受客户端的连接请求 接受&#x2F;发送数据 断开连接 创建套接字1234567891011121314151617socket()函数的用法：头文件#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;函数原型int socket(int domain, int type, int protocol);函数参数domain：选择通信协议，常见的协议：AF_INET：IPv4通信协议AF_INET6：IPv6通信协议AF_UNIX：本地通信type：套接字类型protocol：协议值，通常情况为0函数返回值成功：非负套接字文件描述符失败：-1 12使用markdown嵌入图片 1url https://pic.imgdb.cn/item/65507febc458853aef4c9293.png 1html 1markdownwithlink 1bbcode [img]https://pic.imgdb.cn/item/65507febc458853aef4c9293.png[/img] 1markdown","categories":[{"name":"实训","slug":"实训","permalink":"https://misakivv.github.io/categories/%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-11-11T14:52:18.125Z","updated":"2023-11-11T14:52:18.125Z","comments":true,"path":"2023/11/11/hello-world/","permalink":"https://misakivv.github.io/2023/11/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"实训","slug":"实训","permalink":"https://misakivv.github.io/categories/%E5%AE%9E%E8%AE%AD/"}],"tags":[{"name":"嵌入式 Linux","slug":"嵌入式-Linux","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-Linux/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://misakivv.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}